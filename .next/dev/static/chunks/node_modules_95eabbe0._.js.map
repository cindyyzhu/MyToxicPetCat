{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/cindy/MyToxicPetCat/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js"],"sourcesContent":["/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n        case REACT_VIEW_TRANSITION_TYPE:\n          return \"ViewTransition\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      isValidElement(node)\n        ? node._store && (node._store.validated = 1)\n        : \"object\" === typeof node &&\n          null !== node &&\n          node.$$typeof === REACT_LAZY_TYPE &&\n          (\"fulfilled\" === node._payload.status\n            ? isValidElement(node._payload.value) &&\n              node._payload.value._store &&\n              (node._payload.value._store.validated = 1)\n            : node._store && (node._store.validated = 1));\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    var React = require(\"next/dist/compiled/react\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      if (trackActualOwner) {\n        var previousStackTraceLimit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 10;\n        var debugStackDEV = Error(\"react-stack-top-frame\");\n        Error.stackTraceLimit = previousStackTraceLimit;\n      } else debugStackDEV = unknownOwnerDebugStack;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        debugStackDEV,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/cindy/MyToxicPetCat/node_modules/next/dist/compiled/react/jsx-dev-runtime.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-dev-runtime.production.js');\n} else {\n  module.exports = require('./cjs/react-jsx-dev-runtime.development.js');\n}\n"],"names":[],"mappings":"AAEI;AAFJ;AAEA;;KAEO;IACL,OAAO,OAAO;AAChB","ignoreList":[0]}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@elevenlabs/client/dist/lib.modern.js","sources":["file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/BaseConversation.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/BaseConnection.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/version.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/events.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/overrides.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/errors.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/WebSocketConnection.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/audio.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/createWorkletModuleLoader.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/rawAudioProcessor.generated.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/WebRTCConnection.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/ConnectionFactory.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/compatibility.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/applyDelay.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/TextConversation.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/input.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/audioConcatProcessor.generated.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/output.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/VoiceConversation.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/postOverallFeedback.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/scribe/connection.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/utils/scribeAudioProcessor.generated.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/scribe/scribe.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/client/src/index.ts"],"sourcesContent":["import { Callbacks, Mode, Status } from \"@elevenlabs/types\";\nimport type {\n  BaseConnection,\n  DisconnectionDetails,\n  SessionConfig,\n  FormatConfig,\n} from \"./utils/BaseConnection\";\nimport type {\n  AgentAudioEvent,\n  AgentChatResponsePartEvent,\n  AgentResponseEvent,\n  ClientToolCallEvent,\n  IncomingSocketEvent,\n  InternalTentativeAgentResponseEvent,\n  InterruptionEvent,\n  UserTranscriptionEvent,\n  VadScoreEvent,\n  MCPToolCallClientEvent,\n  AgentToolResponseEvent,\n  ConversationMetadataEvent,\n  AsrInitiationMetadataEvent,\n  MCPConnectionStatusEvent,\n  ErrorMessageEvent,\n  AgentToolRequestEvent,\n} from \"./utils/events\";\nimport type { InputConfig } from \"./utils/input\";\nimport type { OutputConfig } from \"./utils/output\";\n\nexport type { Role, Mode, Status, Callbacks } from \"@elevenlabs/types\";\n\n/** Allows self-hosting the worklets to avoid whitelisting blob: and data: in the CSP script-src  */\nexport type AudioWorkletConfig = {\n  workletPaths?: {\n    rawAudioProcessor?: string;\n    audioConcatProcessor?: string;\n  };\n  libsampleratePath?: string;\n};\n\nexport type Options = SessionConfig &\n  Callbacks &\n  ClientToolsConfig &\n  InputConfig &\n  OutputConfig &\n  AudioWorkletConfig;\n\nexport type PartialOptions = SessionConfig &\n  Partial<Callbacks> &\n  Partial<ClientToolsConfig> &\n  Partial<InputConfig> &\n  Partial<OutputConfig> &\n  Partial<FormatConfig> &\n  Partial<AudioWorkletConfig>;\n\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\n\nconst EMPTY_FREQUENCY_DATA = new Uint8Array(0);\n\nexport function isTextOnly(options: PartialOptions): boolean | undefined {\n  const { textOnly: textOnlyOverride } = options.overrides?.conversation ?? {};\n  const { textOnly } = options;\n  if (typeof textOnly === \"boolean\") {\n    if (\n      typeof textOnlyOverride === \"boolean\" &&\n      textOnly !== textOnlyOverride\n    ) {\n      console.warn(\n        `Conflicting textOnly options provided: ${textOnly} via options.textOnly (will be used) and ${textOnlyOverride} via options.overrides.conversation.textOnly (will be ignored)`\n      );\n    }\n    return textOnly;\n  } else if (typeof textOnlyOverride === \"boolean\") {\n    return textOnlyOverride;\n  } else {\n    return undefined;\n  }\n}\n\nexport class BaseConversation {\n  protected lastInterruptTimestamp = 0;\n  protected mode: Mode = \"listening\";\n  protected status: Status = \"connecting\";\n  protected volume = 1;\n  protected currentEventId = 1;\n  protected lastFeedbackEventId = 0;\n  protected canSendFeedback = false;\n\n  protected static getFullOptions(partialOptions: PartialOptions): Options {\n    const textOnly = isTextOnly(partialOptions);\n    return {\n      clientTools: {},\n      onConnect: () => {},\n      onDebug: () => {},\n      onDisconnect: () => {},\n      onError: () => {},\n      onMessage: () => {},\n      onAudio: () => {},\n      onModeChange: () => {},\n      onStatusChange: () => {},\n      onCanSendFeedbackChange: () => {},\n      onInterruption: () => {},\n      ...partialOptions,\n      textOnly,\n      overrides: {\n        ...partialOptions.overrides,\n        conversation: {\n          ...partialOptions.overrides?.conversation,\n          textOnly,\n        },\n      },\n    };\n  }\n\n  protected constructor(\n    protected readonly options: Options,\n    protected readonly connection: BaseConnection\n  ) {\n    if (this.options.onConnect) {\n      this.options.onConnect({ conversationId: connection.conversationId });\n    }\n    this.connection.onMessage(this.onMessage);\n    this.connection.onDisconnect(this.endSessionWithDetails);\n    this.connection.onModeChange(mode => this.updateMode(mode));\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession() {\n    return this.endSessionWithDetails({ reason: \"user\" });\n  }\n\n  private endSessionWithDetails = async (details: DisconnectionDetails) => {\n    if (this.status !== \"connected\" && this.status !== \"connecting\") return;\n    this.updateStatus(\"disconnecting\");\n    await this.handleEndSession();\n    this.updateStatus(\"disconnected\");\n    if (this.options.onDisconnect) {\n      this.options.onDisconnect(details);\n    }\n  };\n\n  protected async handleEndSession() {\n    this.connection.close();\n  }\n\n  protected updateMode(mode: Mode) {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      if (this.options.onModeChange) {\n        this.options.onModeChange({ mode });\n      }\n    }\n  }\n\n  protected updateStatus(status: Status) {\n    if (status !== this.status) {\n      this.status = status;\n      if (this.options.onStatusChange) {\n        this.options.onStatusChange({ status });\n      }\n    }\n  }\n\n  protected updateCanSendFeedback() {\n    const canSendFeedback = this.currentEventId !== this.lastFeedbackEventId;\n    if (this.canSendFeedback !== canSendFeedback) {\n      this.canSendFeedback = canSendFeedback;\n      if (this.options.onCanSendFeedbackChange) {\n        this.options.onCanSendFeedbackChange({ canSendFeedback });\n      }\n    }\n  }\n\n  protected handleInterruption(event: InterruptionEvent) {\n    if (event.interruption_event) {\n      this.lastInterruptTimestamp = event.interruption_event.event_id;\n\n      if (this.options.onInterruption) {\n        this.options.onInterruption({\n          event_id: event.interruption_event.event_id,\n        });\n      }\n    }\n  }\n\n  protected handleAgentResponse(event: AgentResponseEvent) {\n    if (this.options.onMessage) {\n      this.options.onMessage({\n        source: \"ai\",\n        role: \"agent\",\n        message: event.agent_response_event.agent_response,\n      });\n    }\n  }\n\n  protected handleUserTranscript(event: UserTranscriptionEvent) {\n    if (this.options.onMessage) {\n      this.options.onMessage({\n        source: \"user\",\n        role: \"user\",\n        message: event.user_transcription_event.user_transcript,\n      });\n    }\n  }\n\n  protected handleTentativeAgentResponse(\n    event: InternalTentativeAgentResponseEvent\n  ) {\n    if (this.options.onDebug) {\n      this.options.onDebug({\n        type: \"tentative_agent_response\",\n        response:\n          event.tentative_agent_response_internal_event\n            .tentative_agent_response,\n      });\n    }\n  }\n\n  protected handleVadScore(event: VadScoreEvent) {\n    if (this.options.onVadScore) {\n      this.options.onVadScore({\n        vadScore: event.vad_score_event.vad_score,\n      });\n    }\n  }\n\n  protected async handleClientToolCall(event: ClientToolCallEvent) {\n    if (\n      Object.prototype.hasOwnProperty.call(\n        this.options.clientTools,\n        event.client_tool_call.tool_name\n      )\n    ) {\n      try {\n        const result =\n          (await this.options.clientTools[event.client_tool_call.tool_name](\n            event.client_tool_call.parameters\n          )) ?? \"Client tool execution successful.\"; // default client-tool call response\n\n        // The API expects result to be a string, so we need to convert it if it's not already a string\n        const formattedResult =\n          typeof result === \"object\" ? JSON.stringify(result) : String(result);\n\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: formattedResult,\n          is_error: false,\n        });\n      } catch (e) {\n        this.onError(\n          `Client tool execution failed with following error: ${(e as Error)?.message}`,\n          {\n            clientToolName: event.client_tool_call.tool_name,\n          }\n        );\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: `Client tool execution failed: ${(e as Error)?.message}`,\n          is_error: true,\n        });\n      }\n    } else {\n      if (this.options.onUnhandledClientToolCall) {\n        this.options.onUnhandledClientToolCall(event.client_tool_call);\n\n        return;\n      }\n\n      this.onError(\n        `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        {\n          clientToolName: event.client_tool_call.tool_name,\n        }\n      );\n      this.connection.sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: event.client_tool_call.tool_call_id,\n        result: `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        is_error: true,\n      });\n    }\n  }\n\n  protected handleAudio(event: AgentAudioEvent) {}\n\n  protected handleMCPToolCall(event: MCPToolCallClientEvent) {\n    if (this.options.onMCPToolCall) {\n      this.options.onMCPToolCall(event.mcp_tool_call);\n    }\n  }\n\n  protected handleMCPConnectionStatus(event: MCPConnectionStatusEvent) {\n    if (this.options.onMCPConnectionStatus) {\n      this.options.onMCPConnectionStatus(event.mcp_connection_status);\n    }\n  }\n\n  protected handleAgentToolRequest(event: AgentToolRequestEvent) {\n    if (this.options.onAgentToolRequest) {\n      this.options.onAgentToolRequest(event.agent_tool_request);\n    }\n  }\n\n  protected handleAgentToolResponse(event: AgentToolResponseEvent) {\n    if (event.agent_tool_response.tool_name === \"end_call\") {\n      this.endSessionWithDetails({\n        reason: \"agent\",\n        context: new CloseEvent(\"end_call\", { reason: \"Agent ended the call\" }),\n      });\n    }\n\n    if (this.options.onAgentToolResponse) {\n      this.options.onAgentToolResponse(event.agent_tool_response);\n    }\n  }\n\n  protected handleConversationMetadata(event: ConversationMetadataEvent) {\n    if (this.options.onConversationMetadata) {\n      this.options.onConversationMetadata(\n        event.conversation_initiation_metadata_event\n      );\n    }\n  }\n\n  protected handleAsrInitiationMetadata(event: AsrInitiationMetadataEvent) {\n    if (this.options.onAsrInitiationMetadata) {\n      this.options.onAsrInitiationMetadata(event.asr_initiation_metadata_event);\n    }\n  }\n\n  protected handleAgentChatResponsePart(event: AgentChatResponsePartEvent) {\n    if (this.options.onAgentChatResponsePart) {\n      this.options.onAgentChatResponsePart(event.text_response_part);\n    }\n  }\n\n  protected handleErrorEvent(event: ErrorMessageEvent) {\n    const errorType = event.error_event.error_type;\n    const message =\n      event.error_event.message || event.error_event.reason || \"Unknown error\";\n\n    if (errorType === \"max_duration_exceeded\") {\n      this.endSessionWithDetails({\n        reason: \"error\",\n        message: message,\n        context: new Event(\"max_duration_exceeded\"),\n      });\n      return;\n    }\n\n    this.onError(`Server error: ${message}`, {\n      errorType,\n      code: event.error_event.code,\n      debugMessage: event.error_event.debug_message,\n      details: event.error_event.details,\n    });\n  }\n\n  private onMessage = async (parsedEvent: IncomingSocketEvent) => {\n    switch (parsedEvent.type) {\n      case \"interruption\": {\n        this.handleInterruption(parsedEvent);\n        return;\n      }\n      case \"agent_response\": {\n        this.handleAgentResponse(parsedEvent);\n        return;\n      }\n      case \"user_transcript\": {\n        this.handleUserTranscript(parsedEvent);\n        return;\n      }\n      case \"internal_tentative_agent_response\": {\n        this.handleTentativeAgentResponse(parsedEvent);\n        return;\n      }\n      case \"client_tool_call\": {\n        try {\n          await this.handleClientToolCall(parsedEvent);\n        } catch (error) {\n          this.onError(\n            `Unexpected error in client tool call handling: ${error instanceof Error ? error.message : String(error)}`,\n            {\n              clientToolName: parsedEvent.client_tool_call.tool_name,\n              toolCallId: parsedEvent.client_tool_call.tool_call_id,\n            }\n          );\n        }\n        return;\n      }\n      case \"audio\": {\n        this.handleAudio(parsedEvent);\n        return;\n      }\n\n      case \"vad_score\": {\n        this.handleVadScore(parsedEvent);\n        return;\n      }\n\n      case \"ping\": {\n        this.connection.sendMessage({\n          type: \"pong\",\n          event_id: parsedEvent.ping_event.event_id,\n        });\n        // parsedEvent.ping_event.ping_ms can be used on client side, for example\n        // to warn if ping is too high that experience might be degraded.\n        return;\n      }\n\n      case \"mcp_tool_call\": {\n        this.handleMCPToolCall(parsedEvent);\n        return;\n      }\n\n      case \"mcp_connection_status\": {\n        this.handleMCPConnectionStatus(parsedEvent);\n        return;\n      }\n\n      case \"agent_tool_request\": {\n        this.handleAgentToolRequest(parsedEvent);\n        return;\n      }\n\n      case \"agent_tool_response\": {\n        this.handleAgentToolResponse(parsedEvent);\n        return;\n      }\n\n      case \"conversation_initiation_metadata\": {\n        this.handleConversationMetadata(parsedEvent);\n        return;\n      }\n\n      case \"asr_initiation_metadata\": {\n        this.handleAsrInitiationMetadata(parsedEvent);\n        return;\n      }\n\n      case \"agent_chat_response_part\": {\n        this.handleAgentChatResponsePart(parsedEvent);\n        return;\n      }\n\n      case \"error\": {\n        this.handleErrorEvent(parsedEvent);\n        return;\n      }\n\n      default: {\n        if (this.options.onDebug) {\n          this.options.onDebug(parsedEvent);\n        }\n        return;\n      }\n    }\n  };\n\n  private onError(message: string, context?: any) {\n    console.error(message, context);\n    if (this.options.onError) {\n      this.options.onError(message, context);\n    }\n  }\n\n  public getId() {\n    return this.connection.conversationId;\n  }\n\n  public isOpen() {\n    return this.status === \"connected\";\n  }\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {\n    this.connection.setMicMuted(isMuted);\n  }\n\n  public getInputByteFrequencyData(): Uint8Array {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getInputVolume() {\n    return 0;\n  }\n\n  public getOutputVolume() {\n    return 0;\n  }\n\n  public sendFeedback(like: boolean) {\n    if (!this.canSendFeedback) {\n      console.warn(\n        this.lastFeedbackEventId === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    this.connection.sendMessage({\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: this.currentEventId,\n    });\n    this.lastFeedbackEventId = this.currentEventId;\n    this.updateCanSendFeedback();\n  }\n\n  public sendContextualUpdate(text: string) {\n    this.connection.sendMessage({\n      type: \"contextual_update\",\n      text,\n    });\n  }\n\n  public sendUserMessage(text: string) {\n    this.connection.sendMessage({\n      type: \"user_message\",\n      text,\n    });\n  }\n\n  public sendUserActivity() {\n    this.connection.sendMessage({\n      type: \"user_activity\",\n    });\n  }\n\n  public sendMCPToolApprovalResult(toolCallId: string, isApproved: boolean) {\n    this.connection.sendMessage({\n      type: \"mcp_tool_approval_result\",\n      tool_call_id: toolCallId,\n      is_approved: isApproved,\n    });\n  }\n}\n","import type { IncomingSocketEvent, OutgoingSocketEvent } from \"./events\";\nimport type { Mode } from \"../BaseConversation\";\nimport type { ConversationConfigOverrideAgentLanguage as Language } from \"@elevenlabs/types/generated/types/asyncapi-types\";\nimport type { DisconnectionDetails } from \"@elevenlabs/types\";\n\nexport type {\n  DisconnectionDetails,\n  ConversationConfigOverrideAgentLanguage as Language,\n} from \"@elevenlabs/types\";\n\nexport type DelayConfig = {\n  default: number;\n  android?: number;\n  ios?: number;\n};\n\nexport type FormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n  outputDeviceId?: string;\n};\n\nexport type OnDisconnectCallback = (details: DisconnectionDetails) => void;\nexport type OnMessageCallback = (event: IncomingSocketEvent) => void;\n\nexport type BaseSessionConfig = {\n  origin?: string;\n  authorization?: string;\n  livekitUrl?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n      speed?: number;\n      stability?: number;\n      similarityBoost?: number;\n    };\n    conversation?: {\n      textOnly?: boolean;\n    };\n    client?: {\n      source?: string;\n      version?: string;\n    };\n  };\n  customLlmExtraBody?: unknown;\n  dynamicVariables?: Record<string, string | number | boolean>;\n  useWakeLock?: boolean;\n  connectionDelay?: DelayConfig;\n  textOnly?: boolean;\n  userId?: string;\n};\n\nexport type ConnectionType = \"websocket\" | \"webrtc\";\n\nexport type PublicSessionConfig = BaseSessionConfig & {\n  agentId: string;\n  connectionType: ConnectionType;\n  signedUrl?: never;\n  conversationToken?: never;\n};\n\nexport type PrivateWebSocketSessionConfig = BaseSessionConfig & {\n  signedUrl: string;\n  connectionType?: \"websocket\";\n  agentId?: never;\n  conversationToken?: never;\n};\n\nexport type PrivateWebRTCSessionConfig = BaseSessionConfig & {\n  conversationToken: string;\n  connectionType?: \"webrtc\";\n  agentId?: never;\n  signedUrl?: never;\n};\n\n// Union type for all possible session configurations\nexport type SessionConfig =\n  | PublicSessionConfig\n  | PrivateWebSocketSessionConfig\n  | PrivateWebRTCSessionConfig;\n\nexport abstract class BaseConnection {\n  public abstract readonly conversationId: string;\n  public abstract readonly inputFormat: FormatConfig;\n  public abstract readonly outputFormat: FormatConfig;\n\n  protected queue: IncomingSocketEvent[] = [];\n  protected disconnectionDetails: DisconnectionDetails | null = null;\n  protected onDisconnectCallback: OnDisconnectCallback | null = null;\n  protected onMessageCallback: OnMessageCallback | null = null;\n  protected onModeChangeCallback: ((mode: Mode) => void) | null = null;\n  protected onDebug?: (info: unknown) => void;\n\n  constructor(config: { onDebug?: (info: unknown) => void } = {}) {\n    this.onDebug = config.onDebug;\n  }\n\n  protected debug(info: unknown) {\n    if (this.onDebug) this.onDebug(info);\n  }\n\n  public abstract close(): void;\n  public abstract sendMessage(message: OutgoingSocketEvent): void;\n  public abstract setMicMuted(isMuted: boolean): Promise<void>;\n\n  public onMessage(callback: OnMessageCallback) {\n    this.onMessageCallback = callback;\n    const queue = this.queue;\n    this.queue = [];\n\n    if (queue.length > 0) {\n      // Make sure the queue is flushed after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        queue.forEach(callback);\n      });\n    }\n  }\n\n  public onDisconnect(callback: OnDisconnectCallback) {\n    this.onDisconnectCallback = callback;\n    const details = this.disconnectionDetails;\n    if (details) {\n      // Make sure the event is triggered after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        callback(details);\n      });\n    }\n  }\n\n  public onModeChange(callback: (mode: Mode) => void) {\n    this.onModeChangeCallback = callback;\n  }\n\n  protected updateMode(mode: Mode) {\n    this.onModeChangeCallback?.(mode);\n  }\n\n  protected disconnect(details: DisconnectionDetails) {\n    if (!this.disconnectionDetails) {\n      this.disconnectionDetails = details;\n      this.onDisconnectCallback?.(details);\n    }\n  }\n\n  protected handleMessage(parsedEvent: IncomingSocketEvent) {\n    if (this.onMessageCallback) {\n      this.onMessageCallback(parsedEvent);\n    } else {\n      this.queue.push(parsedEvent);\n    }\n  }\n}\n\nexport function parseFormat(format: string): FormatConfig {\n  const [formatPart, sampleRatePart] = format.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(formatPart)) {\n    throw new Error(`Invalid format: ${format}`);\n  }\n\n  const sampleRate = Number.parseInt(sampleRatePart);\n  if (Number.isNaN(sampleRate)) {\n    throw new Error(`Invalid sample rate: ${sampleRatePart}`);\n  }\n\n  return {\n    format: formatPart as FormatConfig[\"format\"],\n    sampleRate,\n  };\n}\n","// This file is auto-generated during build\nexport const PACKAGE_VERSION = \"0.14.0\";\n","import { Outgoing } from \"@elevenlabs/types\";\nimport type { AudioAlignmentEvent } from \"@elevenlabs/types\";\nimport {\n  AgentChatResponsePartClientEvent,\n  AgentResponse,\n  AgentResponseCorrection,\n  AgentToolResponseClientEvent,\n  AsrInitiationMetadataEvent as AsrMetadataEvent,\n  Audio,\n  AgentToolRequestClientEvent,\n  ClientToolCallMessage,\n  ConversationMetadata,\n  ErrorMessage,\n  Interruption,\n  McpConnectionStatusClientEvent,\n  McpToolCall,\n  Ping,\n  InternalTentativeAgentResponse as TentativeAgentResponseInternal,\n  UserTranscript,\n  VadScore,\n} from \"@elevenlabs/types/generated/types/asyncapi-types\";\n\n// Compatibility layer - incoming events\nexport type UserTranscriptionEvent = UserTranscript;\nexport type AgentResponseEvent = AgentResponse;\nexport type AgentAudioEvent = Audio;\nexport type InterruptionEvent = Interruption;\nexport type InternalTentativeAgentResponseEvent =\n  TentativeAgentResponseInternal;\nexport type ConfigEvent = ConversationMetadata;\nexport type PingEvent = Ping;\nexport type ClientToolCallEvent = ClientToolCallMessage;\nexport type VadScoreEvent = VadScore;\nexport type MCPToolCallClientEvent = McpToolCall;\nexport type AgentResponseCorrectionEvent = AgentResponseCorrection;\nexport type AgentToolRequestEvent = AgentToolRequestClientEvent;\nexport type AgentToolResponseEvent = AgentToolResponseClientEvent;\nexport type ConversationMetadataEvent = ConversationMetadata;\nexport type AsrInitiationMetadataEvent = AsrMetadataEvent;\nexport type MCPConnectionStatusEvent = McpConnectionStatusClientEvent;\nexport type AgentChatResponsePartEvent = AgentChatResponsePartClientEvent;\nexport type ErrorMessageEvent = ErrorMessage;\nexport type { AudioAlignmentEvent };\n\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentResponseCorrectionEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent\n  | VadScoreEvent\n  | MCPToolCallClientEvent\n  | AgentToolRequestEvent\n  | AgentToolResponseEvent\n  | ConversationMetadataEvent\n  | AsrInitiationMetadataEvent\n  | MCPConnectionStatusEvent\n  | AgentChatResponsePartEvent\n  | ErrorMessageEvent;\n\n// Compatibility layer - outgoing events\nexport type PongEvent = Outgoing.PongClientToOrchestratorEvent;\nexport type UserAudioEvent = Outgoing.UserAudio;\nexport type UserFeedbackEvent = Outgoing.UserFeedbackClientToOrchestratorEvent;\nexport type ClientToolResultEvent =\n  Outgoing.ClientToolResultClientToOrchestratorEvent;\nexport type InitiationClientDataEvent =\n  Outgoing.ConversationInitiationClientToOrchestratorEvent;\nexport type ContextualUpdateEvent =\n  Outgoing.ContextualUpdateClientToOrchestratorEvent;\nexport type UserMessageEvent = Outgoing.UserMessageClientToOrchestratorEvent;\nexport type UserActivityEvent = Outgoing.UserActivityClientToOrchestratorEvent;\nexport type MCPToolApprovalResultEvent =\n  Outgoing.McpToolApprovalResultClientToOrchestratorEvent;\n\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | UserFeedbackEvent\n  | ClientToolResultEvent\n  | ContextualUpdateEvent\n  | UserMessageEvent\n  | UserActivityEvent\n  | MCPToolApprovalResultEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n","import type { SessionConfig } from \"./BaseConnection\";\nimport type { InitiationClientDataEvent } from \"./events\";\n\nexport const CONVERSATION_INITIATION_CLIENT_DATA_TYPE =\n  \"conversation_initiation_client_data\";\n\nexport function constructOverrides(\n  config: SessionConfig\n): InitiationClientDataEvent {\n  const overridesEvent: InitiationClientDataEvent = {\n    type: CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n  };\n\n  if (config.overrides) {\n    overridesEvent.conversation_config_override = {\n      agent: {\n        prompt: config.overrides.agent?.prompt,\n        first_message: config.overrides.agent?.firstMessage,\n        language: config.overrides.agent?.language,\n      },\n      tts: {\n        voice_id: config.overrides.tts?.voiceId,\n        speed: config.overrides.tts?.speed,\n        stability: config.overrides.tts?.stability,\n        similarity_boost: config.overrides.tts?.similarityBoost,\n      },\n      conversation: {\n        text_only: config.overrides.conversation?.textOnly,\n      },\n    };\n  }\n\n  if (config.customLlmExtraBody) {\n    overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n  }\n\n  if (config.dynamicVariables) {\n    overridesEvent.dynamic_variables = config.dynamicVariables;\n  }\n\n  if (config.userId) {\n    overridesEvent.user_id = config.userId;\n  }\n\n  if (config.overrides?.client) {\n    overridesEvent.source_info = {\n      source: config.overrides.client.source,\n      version: config.overrides.client.version,\n    };\n  }\n\n  return overridesEvent;\n}\n","export class SessionConnectionError extends Error {\n  public readonly closeCode?: number;\n  public readonly closeReason?: string;\n\n  constructor(\n    message: string,\n    options?: { closeCode?: number; closeReason?: string }\n  ) {\n    super(message);\n    this.name = \"SessionConnectionError\";\n    this.closeCode = options?.closeCode;\n    this.closeReason = options?.closeReason;\n  }\n}\n","import {\n  BaseConnection,\n  type SessionConfig,\n  type FormatConfig,\n  parseFormat,\n} from \"./BaseConnection\";\nimport { PACKAGE_VERSION } from \"../version\";\nimport {\n  type ConfigEvent,\n  isValidSocketEvent,\n  type OutgoingSocketEvent,\n} from \"./events\";\nimport { constructOverrides } from \"./overrides\";\nimport { SessionConnectionError } from \"./errors\";\n\nconst MAIN_PROTOCOL = \"convai\";\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class WebSocketConnection extends BaseConnection {\n  public readonly conversationId: string;\n  public readonly inputFormat: FormatConfig;\n  public readonly outputFormat: FormatConfig;\n\n  private constructor(\n    private readonly socket: WebSocket,\n    conversationId: string,\n    inputFormat: FormatConfig,\n    outputFormat: FormatConfig\n  ) {\n    super();\n    this.conversationId = conversationId;\n    this.inputFormat = inputFormat;\n    this.outputFormat = outputFormat;\n\n    this.socket.addEventListener(\"error\", event => {\n      // In case the error event is followed by a close event, we want the\n      // latter to be the one that disconnects the session as it contains more\n      // useful information.\n      setTimeout(\n        () =>\n          this.disconnect({\n            reason: \"error\",\n            message: \"The connection was closed due to a socket error.\",\n            context: event,\n          }),\n        0\n      );\n    });\n\n    this.socket.addEventListener(\"close\", event => {\n      this.disconnect(\n        event.code === 1000\n          ? {\n              reason: \"agent\",\n              context: event,\n              closeCode: event.code,\n              closeReason: event.reason || undefined,\n            }\n          : {\n              reason: \"error\",\n              message:\n                event.reason || \"The connection was closed by the server.\",\n              context: event,\n              closeCode: event.code,\n              closeReason: event.reason || undefined,\n            }\n      );\n    });\n\n    this.socket.addEventListener(\"message\", event => {\n      try {\n        const parsedEvent = JSON.parse(event.data);\n        if (!isValidSocketEvent(parsedEvent)) {\n          this.debug({\n            type: \"invalid_event\",\n            message: \"Received invalid socket event\",\n            data: event.data,\n          });\n          return;\n        }\n        this.handleMessage(parsedEvent);\n      } catch (error) {\n        this.debug({\n          type: \"parsing_error\",\n          message: \"Failed to parse socket message\",\n          error: error instanceof Error ? error.message : String(error),\n          data: event.data,\n        });\n      }\n    });\n  }\n\n  public static async create(\n    config: SessionConfig\n  ): Promise<WebSocketConnection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      let url: string;\n\n      const version = config.overrides?.client?.version || PACKAGE_VERSION;\n      const source = config.overrides?.client?.source || \"js_sdk\";\n\n      if (config.signedUrl) {\n        const separator = config.signedUrl.includes(\"?\") ? \"&\" : \"?\";\n        url = `${config.signedUrl}${separator}source=${source}&version=${version}`;\n      } else {\n        url = `${origin}${WSS_API_PATHNAME}${config.agentId}&source=${source}&version=${version}`;\n      }\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent = constructOverrides(config);\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n\n        socket!.addEventListener(\"error\", event => {\n          // In case the error event is followed by a close event, we want the\n          // latter to be the one that rejects the promise as it contains more\n          // useful information.\n          setTimeout(\n            () =>\n              reject(\n                new SessionConnectionError(\n                  \"The connection was closed due to a socket error.\"\n                )\n              ),\n            0\n          );\n        });\n\n        socket!.addEventListener(\"close\", (event: CloseEvent) => {\n          const message =\n            event.reason ||\n            (event.code === 1000\n              ? \"Connection closed normally before session could be established.\"\n              : \"Connection closed unexpectedly before session could be established.\");\n          reject(\n            new SessionConnectionError(message, {\n              closeCode: event.code,\n              closeReason: event.reason || undefined,\n            })\n          );\n        });\n\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const {\n        conversation_id,\n        agent_output_audio_format,\n        user_input_audio_format,\n      } = conversationConfig;\n\n      const inputFormat = parseFormat(user_input_audio_format ?? \"pcm_16000\");\n      const outputFormat = parseFormat(agent_output_audio_format);\n\n      return new WebSocketConnection(\n        socket,\n        conversation_id,\n        inputFormat,\n        outputFormat\n      );\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  public close() {\n    this.socket.close(1000, \"User ended conversation\");\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n\n  public async setMicMuted(isMuted: boolean): Promise<void> {\n    console.warn(\n      `WebSocket connection setMicMuted called with ${isMuted}, but this is handled by VoiceConversation`\n    );\n  }\n}\n","export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","const URLCache = new Map<string, string>();\n\nexport function createWorkletModuleLoader(name: string, sourceCode: string) {\n  return async (worklet: AudioWorklet, path?: string) => {\n    const cachedUrl = URLCache.get(name);\n    if (cachedUrl) {\n      return worklet.addModule(cachedUrl);\n    }\n\n    // If a path is provided, use it directly (CSP-friendly approach)\n    if (path) {\n      try {\n        await worklet.addModule(path);\n        URLCache.set(name, path);\n        return;\n      } catch (error) {\n        throw new Error(\n          `Failed to load the ${name} worklet module from path: ${path}. Error: ${error}`\n        );\n      }\n    }\n\n    const blob = new Blob([sourceCode], { type: \"application/javascript\" });\n    const blobURL = URL.createObjectURL(blob);\n    try {\n      await worklet.addModule(blobURL);\n      URLCache.set(name, blobURL);\n      return;\n    } catch {\n      URL.revokeObjectURL(blobURL);\n    }\n\n    try {\n      // Attempting to start a conversation in Safari inside an iframe will\n      // throw a CORS error because the blob:// protocol is considered\n      // cross-origin. In such cases, fall back to using a base64 data URL:\n      const base64 = btoa(sourceCode);\n      const moduleURL = `data:application/javascript;base64,${base64}`;\n      await worklet.addModule(moduleURL);\n      URLCache.set(name, moduleURL);\n    } catch (error) {\n      throw new Error(\n        `Failed to load the ${name} worklet module. Make sure the browser supports AudioWorklets. If you are using a strict CSP, you may need to self-host the worklet files.`\n      );\n    }\n  };\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadRawAudioProcessor = createWorkletModuleLoader(\n  \"rawAudioProcessor\",\n  // language=JavaScript\n  `/*\n * ulaw encoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n * USED BY @elevenlabs/client\n */\n\nconst BIAS = 0x84;\nconst CLIP = 32635;\nconst encodeTable = [\n  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n];\n\nfunction encodeSample(sample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let muLawSample;\n  sign = (sample >> 8) & 0x80;\n  if (sign !== 0) sample = -sample;\n  sample = sample + BIAS;\n  if (sample > CLIP) sample = CLIP;\n  exponent = encodeTable[(sample>>7) & 0xFF];\n  mantissa = (sample >> (exponent+3)) & 0x0F;\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\n  \n  return muLawSample;\n}\n\nclass RawAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n              \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.isMuted = false;\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = data.sampleRate / 10;\n          this.format = data.format;\n\n          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n          break;\n        case \"setMuted\":\n          this.isMuted = data.isMuted;\n          break;\n      }\n    };\n  }\n  process(inputs) {\n    if (!this.buffer) {\n      return true;\n    }\n    \n    const input = inputs[0]; // Get the first input node\n    if (input.length > 0) {\n      let channelData = input[0]; // Get the first channel's data\n\n      // Resample the audio if necessary\n      if (this.resampler) {\n        channelData = this.resampler.full(channelData);\n      }\n\n      // Add channel data to the buffer\n      this.buffer.push(...channelData);\n      // Get max volume \n      let sum = 0.0;\n      for (let i = 0; i < channelData.length; i++) {\n        sum += channelData[i] * channelData[i];\n      }\n      const maxVolume = Math.sqrt(sum / channelData.length);\n      // Check if buffer size has reached or exceeded the threshold\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = this.isMuted \n          ? new Float32Array(this.buffer.length)\n          : new Float32Array(this.buffer);\n\n        let encodedArray = this.format === \"ulaw\"\n          ? new Uint8Array(float32Array.length)\n          : new Int16Array(float32Array.length);\n\n        // Iterate through the Float32Array and convert each sample to PCM16\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to the range [-1, 1]\n          let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n          // Scale the sample to the range [-32768, 32767]\n          let value = sample < 0 ? sample * 32768 : sample * 32767;\n          if (this.format === \"ulaw\") {\n            value = encodeSample(Math.round(value));\n          }\n\n          encodedArray[i] = value;\n        }\n\n        // Send the buffered data to the main script\n        this.port.postMessage([encodedArray, maxVolume]);\n\n        // Clear the buffer after sending\n        this.buffer = [];\n      }\n    }\n    return true; // Continue processing\n  }\n}\nregisterProcessor(\"rawAudioProcessor\", RawAudioProcessor);\n`\n);\n","import {\n  BaseConnection,\n  type SessionConfig,\n  type FormatConfig,\n  parseFormat,\n} from \"./BaseConnection\";\nimport { PACKAGE_VERSION } from \"../version\";\nimport { isValidSocketEvent, type OutgoingSocketEvent } from \"./events\";\nimport {\n  Room,\n  RoomEvent,\n  Track,\n  ConnectionState,\n  createLocalAudioTrack,\n} from \"livekit-client\";\nimport type {\n  RemoteAudioTrack,\n  Participant,\n  TrackPublication,\n  RemoteParticipant,\n} from \"livekit-client\";\nimport {\n  constructOverrides,\n  CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n} from \"./overrides\";\nimport { arrayBufferToBase64 } from \"./audio\";\nimport { loadRawAudioProcessor } from \"./rawAudioProcessor.generated\";\n\nconst DEFAULT_LIVEKIT_WS_URL = \"wss://livekit.rtc.elevenlabs.io\";\nconst HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\n// Convert WSS origin to HTTPS for API calls\nfunction convertWssToHttps(origin: string): string {\n  return origin.replace(/^wss:\\/\\//, \"https://\");\n}\n\nexport type ConnectionConfig = SessionConfig & {\n  onDebug?: (info: unknown) => void;\n};\n\nexport class WebRTCConnection extends BaseConnection {\n  public conversationId: string;\n  public readonly inputFormat: FormatConfig;\n  public readonly outputFormat: FormatConfig;\n\n  private room: Room;\n  private isConnected = false;\n  private audioEventId = 1;\n  private audioCaptureContext: AudioContext | null = null;\n  private audioElements: HTMLAudioElement[] = [];\n  private outputDeviceId: string | null = null;\n\n  private outputAnalyser: AnalyserNode | null = null;\n  private outputFrequencyData: Uint8Array<ArrayBuffer> | null = null;\n\n  private constructor(\n    room: Room,\n    conversationId: string,\n    inputFormat: FormatConfig,\n    outputFormat: FormatConfig,\n    config: { onDebug?: (info: unknown) => void } = {}\n  ) {\n    super(config);\n    this.room = room;\n    this.conversationId = conversationId;\n    this.inputFormat = inputFormat;\n    this.outputFormat = outputFormat;\n\n    this.setupRoomEventListeners();\n  }\n\n  public static async create(\n    config: ConnectionConfig\n  ): Promise<WebRTCConnection> {\n    let conversationToken: string;\n\n    // Handle different authentication scenarios\n    if (\"conversationToken\" in config && config.conversationToken) {\n      // Direct token provided\n      conversationToken = config.conversationToken;\n    } else if (\"agentId\" in config && config.agentId) {\n      // Agent ID provided - fetch token from API\n      try {\n        const version = config.overrides?.client?.version || PACKAGE_VERSION;\n        const source = config.overrides?.client?.source || \"js_sdk\";\n        const configOrigin = config.origin ?? HTTPS_API_ORIGIN;\n        const origin = convertWssToHttps(configOrigin); //origin is wss, not https\n        const url = `${origin}/v1/convai/conversation/token?agent_id=${config.agentId}&source=${source}&version=${version}`;\n        const response = await fetch(url);\n\n        if (!response.ok) {\n          throw new Error(\n            `ElevenLabs API returned ${response.status} ${response.statusText}`\n          );\n        }\n\n        const data = await response.json();\n        conversationToken = data.token;\n\n        if (!conversationToken) {\n          throw new Error(\"No conversation token received from API\");\n        }\n      } catch (error) {\n        let msg = error instanceof Error ? error.message : String(error);\n        if (error instanceof Error && error.message.includes(\"401\")) {\n          msg =\n            \"Your agent has authentication enabled, but no signed URL or conversation token was provided.\";\n        }\n\n        throw new Error(\n          `Failed to fetch conversation token for agent ${config.agentId}: ${msg}`\n        );\n      }\n    } else {\n      throw new Error(\n        \"Either conversationToken or agentId is required for WebRTC connection\"\n      );\n    }\n\n    const room = new Room();\n\n    try {\n      // Create connection instance first to set up event listeners\n      const conversationId = `room_${Date.now()}`;\n      const inputFormat = parseFormat(\"pcm_48000\");\n      const outputFormat = parseFormat(\"pcm_48000\");\n      const connection = new WebRTCConnection(\n        room,\n        conversationId,\n        inputFormat,\n        outputFormat,\n        config\n      );\n\n      // Use configurable LiveKit URL or default if not provided\n      const livekitUrl = config.livekitUrl || DEFAULT_LIVEKIT_WS_URL;\n\n      // Connect to the LiveKit room and wait for the Connected event\n      await room.connect(livekitUrl, conversationToken);\n\n      // Wait for the Connected event to ensure isConnected is true\n      await new Promise<void>(resolve => {\n        if (connection.isConnected) {\n          resolve();\n        } else {\n          const onConnected = () => {\n            room.off(RoomEvent.Connected, onConnected);\n            resolve();\n          };\n          room.on(RoomEvent.Connected, onConnected);\n        }\n      });\n\n      if (room.name) {\n        connection.conversationId =\n          room.name.match(/(conv_[a-zA-Z0-9]+)/)?.[0] || room.name;\n      }\n\n      // Enable microphone only if not text-only mode\n      if (!config.textOnly) {\n        await room.localParticipant.setMicrophoneEnabled(true);\n      }\n\n      const overridesEvent = constructOverrides(config);\n\n      connection.debug({\n        type: CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n        message: overridesEvent,\n      });\n\n      await connection.sendMessage(overridesEvent);\n\n      return connection;\n    } catch (error) {\n      await room.disconnect();\n      throw error;\n    }\n  }\n\n  private setupRoomEventListeners() {\n    this.room.on(RoomEvent.Connected, async () => {\n      this.isConnected = true;\n      console.info(\"WebRTC room connected\");\n    });\n\n    this.room.on(RoomEvent.Disconnected, reason => {\n      this.isConnected = false;\n      this.disconnect({\n        reason: \"agent\",\n        context: new CloseEvent(\"close\", { reason: reason?.toString() }),\n      });\n    });\n\n    this.room.on(RoomEvent.ConnectionStateChanged, state => {\n      if (state === ConnectionState.Disconnected) {\n        this.isConnected = false;\n        this.disconnect({\n          reason: \"error\",\n          message: `LiveKit connection state changed to ${state}`,\n          context: new Event(\"connection_state_changed\"),\n        });\n      }\n    });\n\n    // Handle incoming data messages\n    this.room.on(\n      RoomEvent.DataReceived,\n      (payload: Uint8Array, _participant) => {\n        try {\n          const message = JSON.parse(new TextDecoder().decode(payload));\n\n          // Filter out audio messages for WebRTC - they're handled via audio tracks\n          if (message.type === \"audio\") {\n            return;\n          }\n\n          if (isValidSocketEvent(message)) {\n            this.handleMessage(message);\n          } else {\n            console.warn(\"Invalid socket event received:\", message);\n          }\n        } catch (error) {\n          console.warn(\"Failed to parse incoming data message:\", error);\n          console.warn(\"Raw payload:\", new TextDecoder().decode(payload));\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.TrackSubscribed,\n      async (\n        track: Track,\n        _publication: TrackPublication,\n        participant: Participant\n      ) => {\n        if (\n          track.kind === Track.Kind.Audio &&\n          participant.identity.includes(\"agent\")\n        ) {\n          // Play the audio track\n          const remoteAudioTrack = track as RemoteAudioTrack;\n          const audioElement = remoteAudioTrack.attach();\n          audioElement.autoplay = true;\n          audioElement.controls = false;\n\n          // Set output device if one was previously selected\n          if (this.outputDeviceId && audioElement.setSinkId) {\n            try {\n              await audioElement.setSinkId(this.outputDeviceId);\n            } catch (error) {\n              console.warn(\n                \"Failed to set output device for new audio element:\",\n                error\n              );\n            }\n          }\n\n          // Add to DOM (hidden) to ensure it plays\n          audioElement.style.display = \"none\";\n          document.body.appendChild(audioElement);\n\n          // Store reference for volume control\n          this.audioElements.push(audioElement);\n\n          // Apply current volume if it exists (for when volume was set before audio track arrived)\n          if (this.audioElements.length === 1) {\n            // First audio element - trigger a callback to sync with current volume\n            this.onDebug?.({ type: \"audio_element_ready\" });\n          }\n\n          // Set up audio capture for onAudio callback\n          await this.setupAudioCapture(remoteAudioTrack);\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.ActiveSpeakersChanged,\n      async (speakers: Participant[]) => {\n        if (speakers.length > 0) {\n          this.updateMode(\n            speakers[0].identity.startsWith(\"agent\") ? \"speaking\" : \"listening\"\n          );\n        } else {\n          this.updateMode(\"listening\");\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.ParticipantDisconnected,\n      (participant: RemoteParticipant) => {\n        if (participant.identity?.startsWith(\"agent\")) {\n          this.disconnect({\n            reason: \"agent\",\n            context: new CloseEvent(\"close\", { reason: \"agent disconnected\" }),\n          });\n        }\n      }\n    );\n  }\n\n  public close() {\n    if (this.isConnected) {\n      try {\n        // Explicitly stop all local tracks before disconnecting to ensure microphone is released\n        this.room.localParticipant.audioTrackPublications.forEach(\n          publication => {\n            if (publication.track) {\n              publication.track.stop();\n            }\n          }\n        );\n      } catch (error) {\n        console.warn(\"Error stopping local tracks:\", error);\n      }\n\n      // Clean up audio capture context (non-blocking)\n      if (this.audioCaptureContext) {\n        this.audioCaptureContext.close().catch(error => {\n          console.warn(\"Error closing audio capture context:\", error);\n        });\n        this.audioCaptureContext = null;\n      }\n\n      // Clean up audio elements\n      this.audioElements.forEach(element => {\n        if (element.parentNode) {\n          element.parentNode.removeChild(element);\n        }\n      });\n      this.audioElements = [];\n\n      this.room.disconnect();\n    }\n  }\n\n  public async sendMessage(message: OutgoingSocketEvent) {\n    if (!this.isConnected || !this.room.localParticipant) {\n      console.warn(\n        \"Cannot send message: room not connected or no local participant\"\n      );\n      return;\n    }\n\n    // In WebRTC mode, audio is sent via published tracks, not data messages\n    if (\"user_audio_chunk\" in message) {\n      // Ignore audio data messages - audio flows through WebRTC tracks\n      return;\n    }\n\n    try {\n      const encoder = new TextEncoder();\n      const data = encoder.encode(JSON.stringify(message));\n\n      await this.room.localParticipant.publishData(data, { reliable: true });\n    } catch (error) {\n      this.debug({\n        type: \"send_message_error\",\n        message: {\n          message,\n          error,\n        },\n      });\n      console.error(\"Failed to send message via WebRTC:\", error);\n    }\n  }\n\n  // Get the room instance for advanced usage\n  public getRoom(): Room {\n    return this.room;\n  }\n\n  public async setMicMuted(isMuted: boolean): Promise<void> {\n    if (!this.isConnected || !this.room.localParticipant) {\n      console.warn(\n        \"Cannot set microphone muted: room not connected or no local participant\"\n      );\n      return;\n    }\n\n    // Get the microphone track publication\n    const micTrackPublication = this.room.localParticipant.getTrackPublication(\n      Track.Source.Microphone\n    );\n\n    if (micTrackPublication?.track) {\n      try {\n        // Use LiveKit's built-in track muting\n        if (isMuted) {\n          await micTrackPublication.track.mute();\n        } else {\n          await micTrackPublication.track.unmute();\n        }\n      } catch (_error) {\n        // If track muting fails, fall back to participant-level control\n        await this.room.localParticipant.setMicrophoneEnabled(!isMuted);\n      }\n    } else {\n      // No track found, use participant-level control directly\n      await this.room.localParticipant.setMicrophoneEnabled(!isMuted);\n    }\n  }\n\n  private async setupAudioCapture(track: RemoteAudioTrack) {\n    try {\n      // Create audio context for processing\n      const audioContext = new AudioContext();\n      this.audioCaptureContext = audioContext;\n\n      // Create analyser for frequency data\n      this.outputAnalyser = audioContext.createAnalyser();\n      this.outputAnalyser.fftSize = 2048;\n      this.outputAnalyser.smoothingTimeConstant = 0.8;\n\n      // Create MediaStream from the track\n      const mediaStream = new MediaStream([track.mediaStreamTrack]);\n\n      // Create audio source from the stream\n      const source = audioContext.createMediaStreamSource(mediaStream);\n\n      // Connect source to analyser\n      source.connect(this.outputAnalyser);\n\n      await loadRawAudioProcessor(audioContext.audioWorklet);\n      const worklet = new AudioWorkletNode(audioContext, \"rawAudioProcessor\");\n\n      // Connect analyser to worklet for processing\n      this.outputAnalyser.connect(worklet);\n\n      // Configure the processor for the output format\n      worklet.port.postMessage({\n        type: \"setFormat\",\n        format: this.outputFormat.format,\n        sampleRate: this.outputFormat.sampleRate,\n      });\n\n      // Handle processed audio data\n      worklet.port.onmessage = (event: MessageEvent) => {\n        const [audioData, maxVolume] = event.data;\n\n        // Only send audio if there's significant volume (not just silence)\n        const volumeThreshold = 0.01;\n\n        if (maxVolume > volumeThreshold) {\n          // Convert to base64\n          const base64Audio = arrayBufferToBase64(audioData.buffer);\n\n          // Use sequential event ID for proper feedback tracking\n          const eventId = this.audioEventId++;\n\n          // Trigger the onAudio callback by simulating an audio event\n          this.handleMessage({\n            type: \"audio\",\n            audio_event: {\n              audio_base_64: base64Audio,\n              event_id: eventId,\n            },\n          });\n        }\n      };\n\n      // Connect the audio processing chain\n      source.connect(worklet);\n    } catch (error) {\n      console.warn(\"Failed to set up audio capture:\", error);\n    }\n  }\n\n  public setAudioVolume(volume: number) {\n    this.audioElements.forEach(element => {\n      element.volume = volume;\n    });\n  }\n\n  public async setAudioOutputDevice(deviceId: string): Promise<void> {\n    if (!(\"setSinkId\" in HTMLAudioElement.prototype)) {\n      throw new Error(\"setSinkId is not supported in this browser\");\n    }\n\n    // Set output device for all existing audio elements\n    const promises = this.audioElements.map(async element => {\n      try {\n        await element.setSinkId(deviceId);\n      } catch (error) {\n        console.error(\"Failed to set sink ID for audio element:\", error);\n        throw error;\n      }\n    });\n\n    await Promise.all(promises);\n\n    // Store the device ID for future audio elements\n    this.outputDeviceId = deviceId;\n  }\n\n  public async setAudioInputDevice(deviceId: string): Promise<void> {\n    if (!this.isConnected || !this.room.localParticipant) {\n      throw new Error(\n        \"Cannot change input device: room not connected or no local participant\"\n      );\n    }\n\n    try {\n      // Get the current microphone track publication\n      const currentMicTrackPublication =\n        this.room.localParticipant.getTrackPublication(Track.Source.Microphone);\n\n      // Stop the current microphone track if it exists\n      if (currentMicTrackPublication?.track) {\n        await currentMicTrackPublication.track.stop();\n        await this.room.localParticipant.unpublishTrack(\n          currentMicTrackPublication.track\n        );\n      }\n\n      // Create constraints for the new input device\n      const audioConstraints: MediaTrackConstraints = {\n        deviceId: { exact: deviceId },\n        echoCancellation: true,\n        noiseSuppression: true,\n        autoGainControl: true,\n        channelCount: { ideal: 1 },\n      };\n\n      // Create new audio track with the specified device\n      const audioTrack = await createLocalAudioTrack(audioConstraints);\n\n      // Publish the new microphone track\n      await this.room.localParticipant.publishTrack(audioTrack, {\n        name: \"microphone\",\n        source: Track.Source.Microphone,\n      });\n    } catch (error) {\n      console.error(\"Failed to change input device:\", error);\n\n      // Try to re-enable default microphone on failure\n      try {\n        await this.room.localParticipant.setMicrophoneEnabled(true);\n      } catch (recoveryError) {\n        console.error(\n          \"Failed to recover microphone after device switch error:\",\n          recoveryError\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array<ArrayBuffer> | null {\n    if (!this.outputAnalyser) return null;\n\n    this.outputFrequencyData ??= new Uint8Array(\n      this.outputAnalyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.outputAnalyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  }\n}\n","import type {\n  BaseConnection,\n  SessionConfig,\n  ConnectionType,\n} from \"./BaseConnection\";\nimport { WebSocketConnection } from \"./WebSocketConnection\";\nimport { WebRTCConnection } from \"./WebRTCConnection\";\n\nfunction determineConnectionType(config: SessionConfig): ConnectionType {\n  // If connectionType is explicitly specified, use it\n  if (config.connectionType) {\n    return config.connectionType;\n  }\n\n  // If conversationToken is provided, use WebRTC\n  if (\"conversationToken\" in config && config.conversationToken) {\n    return \"webrtc\";\n  }\n\n  // Default to WebSocket for backward compatibility\n  return \"websocket\";\n}\n\nexport async function createConnection(\n  config: SessionConfig\n): Promise<BaseConnection> {\n  const connectionType = determineConnectionType(config);\n\n  switch (connectionType) {\n    case \"websocket\":\n      return WebSocketConnection.create(config);\n    case \"webrtc\":\n      return WebRTCConnection.create(config);\n    default:\n      throw new Error(`Unknown connection type: ${connectionType}`);\n  }\n}\n","export function isIosDevice() {\n  return (\n    [\n      \"iPad Simulator\",\n      \"iPhone Simulator\",\n      \"iPod Simulator\",\n      \"iPad\",\n      \"iPhone\",\n      \"iPod\",\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n  );\n}\n\nexport function isAndroidDevice() {\n  return /android/i.test(navigator.userAgent);\n}\n","import { isAndroidDevice, isIosDevice } from \"./compatibility\";\nimport type { DelayConfig } from \"./connection\";\n\nexport async function applyDelay(\n  delayConfig: DelayConfig = {\n    default: 0,\n    // Give the Android AudioManager enough time to switch to the correct audio mode\n    android: 3_000,\n  }\n) {\n  let delay = delayConfig.default;\n  if (isAndroidDevice()) {\n    delay = delayConfig.android ?? delay;\n  } else if (isIosDevice()) {\n    delay = delayConfig.ios ?? delay;\n  }\n\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n}\n","import { createConnection } from \"./utils/ConnectionFactory\";\nimport type { BaseConnection } from \"./utils/BaseConnection\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport { BaseConversation, type PartialOptions } from \"./BaseConversation\";\n\nexport class TextConversation extends BaseConversation {\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<TextConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    if (fullOptions.onStatusChange) {\n      fullOptions.onStatusChange({ status: \"connecting\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n    if (fullOptions.onModeChange) {\n      fullOptions.onModeChange({ mode: \"listening\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n\n    let connection: BaseConnection | null = null;\n    try {\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await createConnection(options);\n      return new TextConversation(fullOptions, connection);\n    } catch (error) {\n      if (fullOptions.onStatusChange) {\n        fullOptions.onStatusChange({ status: \"disconnected\" });\n      }\n      connection?.close();\n      throw error;\n    }\n  }\n}\n","import { loadRawAudioProcessor } from \"./rawAudioProcessor.generated\";\nimport type { FormatConfig } from \"./connection\";\nimport { isIosDevice } from \"./compatibility\";\nimport type { AudioWorkletConfig } from \"../BaseConversation\";\n\nexport type InputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n  inputDeviceId?: string;\n  onError?(message: string, context?: unknown): void;\n};\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nconst defaultConstraints = {\n  echoCancellation: true,\n  noiseSuppression: true,\n  // Automatic gain control helps maintain a steady volume level with microphones: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/autoGainControl\n  autoGainControl: true,\n  // Mono audio for better echo cancellation\n  channelCount: { ideal: 1 },\n};\n\nexport class Input {\n  public static async create({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n    inputDeviceId,\n    workletPaths,\n    libsampleratePath,\n    onError,\n  }: FormatConfig & InputConfig & AudioWorkletConfig): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const options: MediaTrackConstraints = {\n        sampleRate: { ideal: sampleRate },\n        ...defaultConstraints,\n      };\n\n      if (isIosDevice() && preferHeadphonesForIosDevices) {\n        const availableDevices =\n          await window.navigator.mediaDevices.enumerateDevices();\n        const idealDevice = availableDevices.find(\n          d =>\n            // cautious to include \"bluetooth\" in the search\n            // as might trigger bluetooth speakers\n            d.kind === \"audioinput\" &&\n            [\"airpod\", \"headphone\", \"earphone\"].find(keyword =>\n              d.label.toLowerCase().includes(keyword)\n            )\n        );\n        if (idealDevice) {\n          options.deviceId = { ideal: idealDevice.deviceId };\n        }\n      }\n\n      if (inputDeviceId) {\n        options.deviceId = Input.getDeviceIdConstraint(inputDeviceId);\n      }\n\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        // Use custom libsamplerate path if provided, otherwise fallback to CDN\n        const libsamplerateUrl = libsampleratePath || LIBSAMPLERATE_JS;\n        await context.audioWorklet.addModule(libsamplerateUrl);\n      }\n      await loadRawAudioProcessor(\n        context.audioWorklet,\n        workletPaths?.[\"rawAudioProcessor\"]\n      );\n\n      const constraints = { voiceIsolation: true, ...options };\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: constraints,\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"rawAudioProcessor\");\n      worklet.port.postMessage({ type: \"setFormat\", format, sampleRate });\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      await context.resume();\n\n      const permissions = await navigator.permissions.query({\n        name: \"microphone\",\n      });\n      return new Input(\n        context,\n        analyser,\n        worklet,\n        inputStream,\n        source,\n        permissions,\n        onError\n      );\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      context?.close();\n      throw error;\n    }\n  }\n\n  // Use { ideal } on iOS as a defensive measure - some iOS versions may not support { exact } for deviceId constraints\n  private static getDeviceIdConstraint(\n    inputDeviceId?: string\n  ): MediaTrackConstraints[\"deviceId\"] {\n    if (!inputDeviceId) {\n      return undefined;\n    }\n    return isIosDevice() ? { ideal: inputDeviceId } : { exact: inputDeviceId };\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public inputStream: MediaStream,\n    private mediaStreamSource: MediaStreamAudioSourceNode,\n    private permissions: PermissionStatus,\n    private onError: (\n      message: string,\n      context?: unknown\n    ) => void = console.error\n  ) {\n    this.permissions.addEventListener(\"change\", this.handlePermissionsChange);\n  }\n\n  private forgetInputStreamAndSource() {\n    for (const track of this.inputStream.getTracks()) {\n      track.stop();\n    }\n    this.mediaStreamSource.disconnect();\n  }\n\n  public async close() {\n    this.forgetInputStreamAndSource();\n    this.permissions.removeEventListener(\n      \"change\",\n      this.handlePermissionsChange\n    );\n    await this.context.close();\n  }\n\n  public setMuted(isMuted: boolean) {\n    this.worklet.port.postMessage({ type: \"setMuted\", isMuted });\n  }\n\n  private settingInput: boolean = false;\n  public async setInputDevice(inputDeviceId?: string): Promise<void> {\n    try {\n      if (this.settingInput) {\n        throw new Error(\"Input device is already being set\");\n      }\n      this.settingInput = true;\n      // Create new constraints with the specified device or use default\n      const options: MediaTrackConstraints = {\n        ...defaultConstraints,\n      };\n\n      if (inputDeviceId) {\n        options.deviceId = Input.getDeviceIdConstraint(inputDeviceId);\n      }\n      // If inputDeviceId is undefined, don't set deviceId constraint - browser uses default\n\n      const constraints = { voiceIsolation: true, ...options };\n\n      // Get new media stream with the specified device before forgetting the old one\n      // this prevents unintended interruption of the audio stream in case the new stream isn't obtained\n      const newInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: constraints,\n      });\n\n      this.forgetInputStreamAndSource();\n\n      // Replace the stream and create new source\n      this.inputStream = newInputStream;\n      this.mediaStreamSource =\n        this.context.createMediaStreamSource(newInputStream);\n\n      // Reconnect the audio graph\n      this.mediaStreamSource.connect(this.analyser);\n    } catch (error) {\n      this.onError(\"Failed to switch input device:\", error);\n      throw error;\n    } finally {\n      this.settingInput = false;\n    }\n  }\n\n  private handlePermissionsChange = () => {\n    if (this.permissions.state === \"denied\") {\n      this.onError(\"Microphone permission denied\");\n      // TODO: Tell the user to grant permission in some other way\n    } else if (!this.settingInput) {\n      // Let's try to reset the input device, but only if we're not already in the process of setting it\n      const [track] = this.inputStream.getAudioTracks();\n      const { deviceId } = track?.getSettings() ?? {};\n      this.setInputDevice(deviceId).catch(error => {\n        this.onError(\n          \"Failed to reset input device after permission change:\",\n          error\n        );\n      });\n    }\n  };\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadAudioConcatProcessor = createWorkletModuleLoader(\n  \"audioConcatProcessor\",\n  // language=JavaScript\n  `/*\n * ulaw decoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n * USED BY @elevenlabs/client\n */\n\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\n\nfunction decodeSample(muLawSample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let sample;\n  muLawSample = ~muLawSample;\n  sign = (muLawSample & 0x80);\n  exponent = (muLawSample >> 4) & 0x07;\n  mantissa = muLawSample & 0x0F;\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\n  if (sign !== 0) sample = -sample;\n\n  return sample;\n}\n\nclass AudioConcatProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffers = []; // Initialize an empty buffer\n    this.cursor = 0;\n    this.currentBuffer = null;\n    this.wasInterrupted = false;\n    this.finished = false;\n    \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.format = data.format;\n          break;\n        case \"buffer\":\n          this.wasInterrupted = false;\n          this.buffers.push(\n            this.format === \"ulaw\"\n              ? new Uint8Array(data.buffer)\n              : new Int16Array(data.buffer)\n          );\n          break;\n        case \"interrupt\":\n          this.wasInterrupted = true;\n          break;\n        case \"clearInterrupted\":\n          if (this.wasInterrupted) {\n            this.wasInterrupted = false;\n            this.buffers = [];\n            this.currentBuffer = null;\n          }\n      }\n    };\n  }\n  process(_, outputs) {\n    let finished = false;\n    const output = outputs[0][0];\n    for (let i = 0; i < output.length; i++) {\n      if (!this.currentBuffer) {\n        if (this.buffers.length === 0) {\n          finished = true;\n          break;\n        }\n        this.currentBuffer = this.buffers.shift();\n        this.cursor = 0;\n      }\n\n      let value = this.currentBuffer[this.cursor];\n      if (this.format === \"ulaw\") {\n        value = decodeSample(value);\n      }\n      output[i] = value / 32768;\n      this.cursor++;\n\n      if (this.cursor >= this.currentBuffer.length) {\n        this.currentBuffer = null;\n      }\n    }\n\n    if (this.finished !== finished) {\n      this.finished = finished;\n      this.port.postMessage({ type: \"process\", finished });\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"audioConcatProcessor\", AudioConcatProcessor);\n`\n);\n","import { loadAudioConcatProcessor } from \"./audioConcatProcessor.generated\";\nimport type { FormatConfig } from \"./connection\";\nimport type { AudioWorkletConfig } from \"../BaseConversation\";\n\nexport type OutputConfig = {\n  outputDeviceId?: string;\n};\n\nexport class Output {\n  public static async create({\n    sampleRate,\n    format,\n    outputDeviceId,\n    workletPaths,\n  }: FormatConfig & OutputConfig & AudioWorkletConfig): Promise<Output> {\n    let context: AudioContext | null = null;\n    let audioElement: HTMLAudioElement | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n\n      // Always create an audio element for device switching capability\n      audioElement = new Audio();\n      audioElement.src = \"\";\n      audioElement.load();\n      audioElement.autoplay = true;\n      audioElement.style.display = \"none\";\n\n      document.body.appendChild(audioElement);\n\n      // Create media stream destination to route audio to the element\n      const destination = context.createMediaStreamDestination();\n      audioElement.srcObject = destination.stream;\n\n      gain.connect(analyser);\n      analyser.connect(destination);\n\n      await loadAudioConcatProcessor(\n        context.audioWorklet,\n        workletPaths?.[\"audioConcatProcessor\"]\n      );\n      const worklet = new AudioWorkletNode(context, \"audioConcatProcessor\");\n      worklet.port.postMessage({ type: \"setFormat\", format });\n      worklet.connect(gain);\n\n      await context.resume();\n\n      // Set initial output device if provided\n      if (outputDeviceId && audioElement.setSinkId) {\n        await audioElement.setSinkId(outputDeviceId);\n      }\n\n      const newOutput = new Output(\n        context,\n        analyser,\n        gain,\n        worklet,\n        audioElement\n      );\n\n      return newOutput;\n    } catch (error) {\n      // Clean up audio element from DOM\n      if (audioElement?.parentNode) {\n        audioElement.parentNode.removeChild(audioElement);\n      }\n      audioElement?.pause();\n      if (context && context.state !== \"closed\") {\n        await context.close();\n      }\n\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly audioElement: HTMLAudioElement\n  ) {}\n\n  public async setOutputDevice(deviceId?: string): Promise<void> {\n    if (!(\"setSinkId\" in HTMLAudioElement.prototype)) {\n      throw new Error(\"setSinkId is not supported in this browser\");\n    }\n\n    // If deviceId is undefined, use empty string which resets to default device\n    await this.audioElement.setSinkId(deviceId || \"\");\n  }\n\n  public async close() {\n    // Remove audio element from DOM\n    if (this.audioElement.parentNode) {\n      this.audioElement.parentNode.removeChild(this.audioElement);\n    }\n    this.audioElement.pause();\n    await this.context.close();\n  }\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input, type InputConfig } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { createConnection } from \"./utils/ConnectionFactory\";\nimport type { BaseConnection, FormatConfig } from \"./utils/BaseConnection\";\nimport { WebRTCConnection } from \"./utils/WebRTCConnection\";\nimport type { AgentAudioEvent, InterruptionEvent } from \"./utils/events\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport {\n  BaseConversation,\n  type Options,\n  type PartialOptions,\n} from \"./BaseConversation\";\nimport { WebSocketConnection } from \"./utils/WebSocketConnection\";\n\nexport class VoiceConversation extends BaseConversation {\n  private static async requestWakeLock(): Promise<WakeLockSentinel | null> {\n    if (\"wakeLock\" in navigator) {\n      // unavailable without HTTPS, including localhost in dev\n      try {\n        return await navigator.wakeLock.request(\"screen\");\n      } catch (_e) {\n        // Wake Lock is not required for the conversation to work\n      }\n    }\n    return null;\n  }\n\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<VoiceConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    if (fullOptions.onStatusChange) {\n      fullOptions.onStatusChange({ status: \"connecting\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n\n    let input: Input | null = null;\n    let connection: BaseConnection | null = null;\n    let output: Output | null = null;\n    let preliminaryInputStream: MediaStream | null = null;\n\n    const useWakeLock = options.useWakeLock ?? true;\n    let wakeLock: WakeLockSentinel | null = null;\n    if (useWakeLock) {\n      wakeLock = await VoiceConversation.requestWakeLock();\n    }\n\n    try {\n      // some browsers won't allow calling getSupportedConstraints or enumerateDevices\n      // before getting approval for microphone access\n      preliminaryInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await createConnection(options);\n      [input, output] = await Promise.all([\n        Input.create({\n          ...connection.inputFormat,\n          preferHeadphonesForIosDevices: options.preferHeadphonesForIosDevices,\n          inputDeviceId: options.inputDeviceId,\n          workletPaths: options.workletPaths,\n          libsampleratePath: options.libsampleratePath,\n        }),\n        Output.create({\n          ...connection.outputFormat,\n          outputDeviceId: options.outputDeviceId,\n          workletPaths: options.workletPaths,\n        }),\n      ]);\n\n      preliminaryInputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      preliminaryInputStream = null;\n\n      return new VoiceConversation(\n        fullOptions,\n        connection,\n        input,\n        output,\n        wakeLock\n      );\n    } catch (error) {\n      if (fullOptions.onStatusChange) {\n        fullOptions.onStatusChange({ status: \"disconnected\" });\n      }\n      preliminaryInputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      try {\n        await wakeLock?.release();\n        wakeLock = null;\n      } catch (_e) {}\n      throw error;\n    }\n  }\n\n  private inputFrequencyData?: Uint8Array<ArrayBuffer>;\n  private outputFrequencyData?: Uint8Array<ArrayBuffer>;\n  private visibilityChangeHandler: (() => void) | null = null;\n\n  protected constructor(\n    options: Options,\n    connection: BaseConnection,\n    public input: Input,\n    public output: Output,\n    public wakeLock: WakeLockSentinel | null\n  ) {\n    super(options, connection);\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n\n    if (wakeLock) {\n      // Wake locks are automatically released when a page is hidden like when switching tabs\n      // so attempt to re-acquire lock when page becomes visible again\n      this.visibilityChangeHandler = () => {\n        if (document.visibilityState === \"visible\" && this.wakeLock?.released) {\n          VoiceConversation.requestWakeLock().then(lock => {\n            this.wakeLock = lock;\n          });\n        }\n      };\n      document.addEventListener(\n        \"visibilitychange\",\n        this.visibilityChangeHandler\n      );\n    }\n  }\n\n  protected override async handleEndSession() {\n    await super.handleEndSession();\n\n    if (this.visibilityChangeHandler) {\n      document.removeEventListener(\n        \"visibilitychange\",\n        this.visibilityChangeHandler\n      );\n    }\n\n    try {\n      await this.wakeLock?.release();\n      this.wakeLock = null;\n    } catch (_e) {}\n\n    await this.input.close();\n    await this.output.close();\n  }\n\n  protected override handleInterruption(event: InterruptionEvent) {\n    super.handleInterruption(event);\n    this.fadeOutAudio();\n  }\n\n  protected override handleAudio(event: AgentAudioEvent) {\n    super.handleAudio(event);\n\n    if (event.audio_event.alignment && this.options.onAudioAlignment) {\n      this.options.onAudioAlignment(event.audio_event.alignment);\n    }\n\n    if (this.lastInterruptTimestamp <= event.audio_event.event_id) {\n      if (event.audio_event.audio_base_64) {\n        this.options.onAudio?.(event.audio_event.audio_base_64);\n\n        // Only play audio through the output worklet for WebSocket connections\n        // WebRTC connections handle audio playback directly through LiveKit tracks\n        if (!(this.connection instanceof WebRTCConnection)) {\n          this.addAudioBase64Chunk(event.audio_event.audio_base_64);\n        }\n      }\n\n      this.currentEventId = event.audio_event.event_id;\n      this.updateCanSendFeedback();\n      this.updateMode(\"speaking\");\n    }\n  }\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n\n    // TODO: When supported, maxVolume can be used to avoid sending silent audio\n    // const maxVolume = event.data[1];\n\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n      });\n    }\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = (chunk: string) => {\n    this.output.gain.gain.cancelScheduledValues(\n      this.output.context.currentTime\n    );\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {\n    // Use LiveKit track muting for WebRTC connections\n    if (this.connection instanceof WebRTCConnection) {\n      this.connection.setMicMuted(isMuted);\n    } else {\n      // Use input muting for WebSocket connections\n      this.input.setMuted(isMuted);\n    }\n  }\n\n  public getInputByteFrequencyData(): Uint8Array<ArrayBuffer> {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array<ArrayBuffer> {\n    // Use WebRTC analyser if available\n    if (this.connection instanceof WebRTCConnection) {\n      const webrtcData = this.connection.getOutputByteFrequencyData();\n      if (webrtcData) {\n        return webrtcData as Uint8Array<ArrayBuffer>;\n      }\n      // Fallback to empty array if WebRTC analyser not ready\n      return new Uint8Array(1024) as Uint8Array<ArrayBuffer>;\n    }\n\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  }\n\n  public getInputVolume() {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  }\n\n  public getOutputVolume() {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  }\n\n  public async changeInputDevice({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n    inputDeviceId,\n  }: FormatConfig & InputConfig): Promise<Input> {\n    try {\n      // For WebSocket connections, try to change device on existing input first\n      if (this.connection instanceof WebSocketConnection) {\n        try {\n          await this.input.setInputDevice(inputDeviceId);\n          return this.input;\n        } catch (error) {\n          console.warn(\n            \"Failed to change device on existing input, recreating:\",\n            error\n          );\n          // Fall back to recreating the input\n        }\n      }\n\n      // Handle WebRTC connections differently\n      if (this.connection instanceof WebRTCConnection) {\n        await this.connection.setAudioInputDevice(inputDeviceId || \"\");\n      }\n\n      // Fallback: recreate the input\n      await this.input.close();\n\n      const newInput = await Input.create({\n        sampleRate: sampleRate ?? this.connection.inputFormat.sampleRate,\n        format: format ?? this.connection.inputFormat.format,\n        preferHeadphonesForIosDevices,\n        inputDeviceId,\n        workletPaths: this.options.workletPaths,\n        libsampleratePath: this.options.libsampleratePath,\n        onError: this.options.onError,\n      });\n\n      this.input = newInput;\n      this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n\n      return this.input;\n    } catch (error) {\n      console.error(\"Error changing input device\", error);\n      throw error;\n    }\n  }\n\n  public async changeOutputDevice({\n    sampleRate,\n    format,\n    outputDeviceId,\n  }: FormatConfig): Promise<Output> {\n    try {\n      // For WebSocket connections, try to change device on existing output first\n      if (this.connection instanceof WebSocketConnection) {\n        try {\n          await this.output.setOutputDevice(outputDeviceId);\n          return this.output;\n        } catch (error) {\n          console.warn(\n            \"Failed to change device on existing output, recreating:\",\n            error\n          );\n          // Fall back to recreating the output\n        }\n      }\n\n      // Handle WebRTC connections differently\n      if (this.connection instanceof WebRTCConnection) {\n        await this.connection.setAudioOutputDevice(outputDeviceId || \"\");\n      }\n\n      // Fallback: recreate the output\n      await this.output.close();\n\n      const newOutput = await Output.create({\n        sampleRate: sampleRate ?? this.connection.outputFormat.sampleRate,\n        format: format ?? this.connection.outputFormat.format,\n        outputDeviceId,\n        workletPaths: this.options.workletPaths,\n      });\n\n      this.output = newOutput;\n\n      return this.output;\n    } catch (error) {\n      console.error(\"Error changing output device\", error);\n      throw error;\n    }\n  }\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    // clamp & coerce\n    const clampedVolume = Number.isFinite(volume)\n      ? Math.min(1, Math.max(0, volume))\n      : 1;\n    this.volume = clampedVolume;\n\n    if (this.connection instanceof WebRTCConnection) {\n      // For WebRTC connections, control volume via HTML audio elements\n      this.connection.setAudioVolume(clampedVolume);\n    } else {\n      // For WebSocket connections, control volume via gain node\n      this.output.gain.gain.value = clampedVolume;\n    }\n  };\n}\n","const HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\nexport interface RatingFeedback {\n  rating: number;\n  comment?: string;\n}\n\ntype Feedback = RatingFeedback;\n\nexport function postOverallFeedback(\n  conversationId: string,\n  like: boolean,\n  origin?: string\n): Promise<Response>;\nexport function postOverallFeedback(\n  conversationId: string,\n  feedback: Feedback,\n  origin?: string\n): Promise<Response>;\nexport function postOverallFeedback(\n  conversationId: string,\n  likeOrFeedback: boolean | Feedback,\n  origin: string = HTTPS_API_ORIGIN\n): Promise<Response> {\n  const body: {\n    feedback?: \"like\" | \"dislike\";\n    rating?: number;\n    comment?: string;\n  } = {};\n\n  if (typeof likeOrFeedback === \"boolean\") {\n    body.feedback = likeOrFeedback ? \"like\" : \"dislike\";\n  } else {\n    body.rating = likeOrFeedback.rating;\n    body.comment = likeOrFeedback.comment;\n  }\n\n  return fetch(`${origin}/v1/convai/conversations/${conversationId}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n","import type {\n  InputAudioChunk,\n  SessionStartedMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"@elevenlabs/types\";\n\n// Re-export types for public API\nexport type {\n  SessionStartedMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n};\n\nexport type WebSocketMessage =\n  | SessionStartedMessage\n  | PartialTranscriptMessage\n  | CommittedTranscriptMessage\n  | CommittedTranscriptWithTimestampsMessage\n  | ScribeErrorMessage\n  | ScribeAuthErrorMessage\n  | ScribeQuotaExceededErrorMessage\n  | ScribeCommitThrottledErrorMessage\n  | ScribeTranscriberErrorMessage\n  | ScribeUnacceptedTermsErrorMessage\n  | ScribeRateLimitedErrorMessage\n  | ScribeInputErrorMessage\n  | ScribeQueueOverflowErrorMessage\n  | ScribeResourceExhaustedErrorMessage\n  | ScribeSessionTimeLimitExceededErrorMessage\n  | ScribeChunkSizeExceededErrorMessage\n  | ScribeInsufficientAudioActivityErrorMessage;\n\n/**\n * Simple EventEmitter implementation for browser compatibility.\n */\nclass EventEmitter {\n  private listeners: Map<string, Set<(...args: unknown[]) => void>> = new Map();\n\n  on(event: string, listener: (...args: unknown[]) => void): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.add(listener);\n    }\n  }\n\n  off(event: string, listener: (...args: unknown[]) => void): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n    }\n  }\n\n  emit(event: string, ...args: unknown[]): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(listener => {\n        listener(...args);\n      });\n    }\n  }\n}\n\n/**\n * Events emitted by the RealtimeConnection.\n */\nexport enum RealtimeEvents {\n  /** Emitted when the session is successfully started */\n  SESSION_STARTED = \"session_started\",\n  /** Emitted when a partial (interim) transcript is available */\n  PARTIAL_TRANSCRIPT = \"partial_transcript\",\n  /** Emitted when a final transcript is available */\n  COMMITTED_TRANSCRIPT = \"committed_transcript\",\n  /** Emitted when a final transcript with timestamps is available */\n  COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS = \"committed_transcript_with_timestamps\",\n  /** Emitted when an authentication error occurs */\n  AUTH_ERROR = \"auth_error\",\n  /** Emitted when an error occurs (also emitted for all specific error types) */\n  ERROR = \"error\",\n  /** Emitted when the WebSocket connection is opened */\n  OPEN = \"open\",\n  /** Emitted when the WebSocket connection is closed */\n  CLOSE = \"close\",\n  /** Emitted when a quota exceeded error occurs */\n  QUOTA_EXCEEDED = \"quota_exceeded\",\n  /** Emitted when commit is throttled */\n  COMMIT_THROTTLED = \"commit_throttled\",\n  /** Emitted when a transcriber error occurs */\n  TRANSCRIBER_ERROR = \"transcriber_error\",\n  /** Emitted when terms have not been accepted */\n  UNACCEPTED_TERMS = \"unaccepted_terms\",\n  /** Emitted when rate limited */\n  RATE_LIMITED = \"rate_limited\",\n  /** Emitted when there's an input error */\n  INPUT_ERROR = \"input_error\",\n  /** Emitted when the queue overflows */\n  QUEUE_OVERFLOW = \"queue_overflow\",\n  /** Emitted when resources are exhausted */\n  RESOURCE_EXHAUSTED = \"resource_exhausted\",\n  /** Emitted when session time limit is exceeded */\n  SESSION_TIME_LIMIT_EXCEEDED = \"session_time_limit_exceeded\",\n  /** Emitted when chunk size is exceeded */\n  CHUNK_SIZE_EXCEEDED = \"chunk_size_exceeded\",\n  /** Emitted when there's insufficient audio activity */\n  INSUFFICIENT_AUDIO_ACTIVITY = \"insufficient_audio_activity\",\n}\n\n/**\n * Map of event types to their payload types.\n */\nexport interface RealtimeEventMap {\n  [RealtimeEvents.SESSION_STARTED]: SessionStartedMessage;\n  [RealtimeEvents.PARTIAL_TRANSCRIPT]: PartialTranscriptMessage;\n  [RealtimeEvents.COMMITTED_TRANSCRIPT]: CommittedTranscriptMessage;\n  [RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS]: CommittedTranscriptWithTimestampsMessage;\n  [RealtimeEvents.ERROR]: ScribeErrorMessage;\n  [RealtimeEvents.AUTH_ERROR]: ScribeAuthErrorMessage;\n  [RealtimeEvents.QUOTA_EXCEEDED]: ScribeQuotaExceededErrorMessage;\n  [RealtimeEvents.COMMIT_THROTTLED]: ScribeCommitThrottledErrorMessage;\n  [RealtimeEvents.TRANSCRIBER_ERROR]: ScribeTranscriberErrorMessage;\n  [RealtimeEvents.UNACCEPTED_TERMS]: ScribeUnacceptedTermsErrorMessage;\n  [RealtimeEvents.RATE_LIMITED]: ScribeRateLimitedErrorMessage;\n  [RealtimeEvents.INPUT_ERROR]: ScribeInputErrorMessage;\n  [RealtimeEvents.QUEUE_OVERFLOW]: ScribeQueueOverflowErrorMessage;\n  [RealtimeEvents.RESOURCE_EXHAUSTED]: ScribeResourceExhaustedErrorMessage;\n  [RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED]: ScribeSessionTimeLimitExceededErrorMessage;\n  [RealtimeEvents.CHUNK_SIZE_EXCEEDED]: ScribeChunkSizeExceededErrorMessage;\n  [RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY]: ScribeInsufficientAudioActivityErrorMessage;\n  [RealtimeEvents.OPEN]: undefined;\n  [RealtimeEvents.CLOSE]: CloseEvent;\n}\n\n/**\n * Manages a real-time transcription WebSocket connection.\n *\n * @example\n * ```typescript\n * const connection = await Scribe.connect({\n *     token: \"...\",\n *     modelId: \"scribe_v2_realtime\",\n *     audioFormat: AudioFormat.PCM_16000,\n *     sampleRate: 16000,\n * });\n *\n * connection.on(RealtimeEvents.SESSION_STARTED, (data) => {\n *     console.log(\"Session started\");\n * });\n *\n * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data) => {\n *     console.log(\"Partial:\", data.transcript);\n * });\n *\n * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n *     console.log(\"Final:\", data.transcript);\n *     connection.close();\n * });\n *\n * // Send audio data\n * connection.send({ audioBase64: base64String });\n *\n * // Commit and close\n * connection.commit();\n * ```\n */\nexport class RealtimeConnection {\n  private websocket: WebSocket | null = null;\n  private eventEmitter: EventEmitter = new EventEmitter();\n  private currentSampleRate: number = 16000;\n  public _audioCleanup?: () => void;\n\n  constructor(sampleRate: number) {\n    this.currentSampleRate = sampleRate;\n  }\n\n  /**\n   * @internal\n   * Used internally by ScribeRealtime to attach the WebSocket after connection is created.\n   */\n  public setWebSocket(websocket: WebSocket): void {\n    this.websocket = websocket;\n\n    // If WebSocket is already open, emit OPEN event immediately\n    if (this.websocket.readyState === WebSocket.OPEN) {\n      this.eventEmitter.emit(RealtimeEvents.OPEN);\n    } else {\n      // Otherwise, wait for the open event\n      this.websocket.addEventListener(\"open\", () => {\n        this.eventEmitter.emit(RealtimeEvents.OPEN);\n      });\n    }\n\n    this.websocket.addEventListener(\"message\", (event: MessageEvent) => {\n      try {\n        const data = JSON.parse(event.data) as WebSocketMessage;\n\n        switch (data.message_type) {\n          case \"session_started\":\n            this.eventEmitter.emit(RealtimeEvents.SESSION_STARTED, data);\n            break;\n          case \"partial_transcript\":\n            this.eventEmitter.emit(RealtimeEvents.PARTIAL_TRANSCRIPT, data);\n            break;\n          case \"committed_transcript\":\n            this.eventEmitter.emit(RealtimeEvents.COMMITTED_TRANSCRIPT, data);\n            break;\n          case \"committed_transcript_with_timestamps\":\n            this.eventEmitter.emit(\n              RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS,\n              data\n            );\n            break;\n          // Error cases - emit both specific event and generic ERROR\n          case \"auth_error\":\n            this.eventEmitter.emit(RealtimeEvents.AUTH_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"quota_exceeded\":\n            this.eventEmitter.emit(RealtimeEvents.QUOTA_EXCEEDED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"commit_throttled\":\n            this.eventEmitter.emit(RealtimeEvents.COMMIT_THROTTLED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"transcriber_error\":\n            this.eventEmitter.emit(RealtimeEvents.TRANSCRIBER_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"unaccepted_terms\":\n            this.eventEmitter.emit(RealtimeEvents.UNACCEPTED_TERMS, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"rate_limited\":\n            this.eventEmitter.emit(RealtimeEvents.RATE_LIMITED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"input_error\":\n            this.eventEmitter.emit(RealtimeEvents.INPUT_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"queue_overflow\":\n            this.eventEmitter.emit(RealtimeEvents.QUEUE_OVERFLOW, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"resource_exhausted\":\n            this.eventEmitter.emit(RealtimeEvents.RESOURCE_EXHAUSTED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"session_time_limit_exceeded\":\n            this.eventEmitter.emit(\n              RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED,\n              data\n            );\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"chunk_size_exceeded\":\n            this.eventEmitter.emit(RealtimeEvents.CHUNK_SIZE_EXCEEDED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"insufficient_audio_activity\":\n            this.eventEmitter.emit(\n              RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY,\n              data\n            );\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"error\":\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          default:\n            console.warn(\"Unknown message type:\", data);\n        }\n      } catch (error) {\n        console.error(\"Failed to parse WebSocket message:\", error, event.data);\n        this.eventEmitter.emit(\n          RealtimeEvents.ERROR,\n          new Error(`Failed to parse message: ${error}`)\n        );\n      }\n    });\n\n    this.websocket.addEventListener(\"error\", (error: Event) => {\n      console.error(\"WebSocket error:\", error);\n      this.eventEmitter.emit(RealtimeEvents.ERROR, error);\n    });\n\n    this.websocket.addEventListener(\"close\", (event: CloseEvent) => {\n      console.log(\n        `WebSocket closed: code=${event.code}, reason=\"${event.reason}\", wasClean=${event.wasClean}`\n      );\n\n      // Emit error if close was not clean or had an error code\n      if (!event.wasClean || (event.code !== 1000 && event.code !== 1005)) {\n        const errorMessage = `WebSocket closed unexpectedly: ${event.code} - ${event.reason || \"No reason provided\"}`;\n        console.error(errorMessage);\n        this.eventEmitter.emit(RealtimeEvents.ERROR, new Error(errorMessage));\n      }\n\n      this.eventEmitter.emit(RealtimeEvents.CLOSE, event);\n    });\n  }\n\n  /**\n   * Attaches an event listener for the specified event.\n   *\n   * @param event - The event to listen for (use RealtimeEvents enum)\n   * @param listener - The callback function to execute when the event fires\n   *\n   * @example\n   * ```typescript\n   * connection.on(RealtimeEvents.SESSION_STARTED, (data) => {\n   *     console.log(\"Session started\", data.session_id);\n   * });\n   *\n   * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data) => {\n   *     console.log(\"Partial:\", data.text);\n   * });\n   *\n   * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n   *     console.log(\"Final:\", data.text);\n   * });\n   * ```\n   */\n  public on<E extends RealtimeEvents>(\n    event: E,\n    listener: RealtimeEventMap[E] extends undefined\n      ? () => void\n      : (data: RealtimeEventMap[E]) => void\n  ): void {\n    this.eventEmitter.on(event, listener as (...args: unknown[]) => void);\n  }\n\n  /**\n   * Removes an event listener for the specified event.\n   *\n   * @param event - The event to stop listening for\n   * @param listener - The callback function to remove\n   *\n   * @example\n   * ```typescript\n   * const handler = (data: PartialTranscriptMessage) => console.log(data.text);\n   * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, handler);\n   *\n   * // Later, remove the listener\n   * connection.off(RealtimeEvents.PARTIAL_TRANSCRIPT, handler);\n   * ```\n   */\n  public off<E extends RealtimeEvents>(\n    event: E,\n    listener: RealtimeEventMap[E] extends undefined\n      ? () => void\n      : (data: RealtimeEventMap[E]) => void\n  ): void {\n    this.eventEmitter.off(event, listener as (...args: unknown[]) => void);\n  }\n\n  /**\n   * Sends audio data to the transcription service.\n   *\n   * @param data - Audio data configuration\n   * @param data.audioBase64 - Base64-encoded audio data\n   * @param data.commit - Whether to commit the transcription after this chunk. You likely want to use connection.commit() instead (default: false)\n   * @param data.sampleRate - Sample rate of the audio (default: configured sample rate)\n   * @param data.previousText - Send context to the model via base64 encoded audio or text from a previous transcription. Can only be sent alongside the first audio chunk. If sent in a subsequent chunk, an error will be returned.\n   *\n   * @throws {Error} If the WebSocket connection is not open\n   *\n   * @example\n   * ```typescript\n   * // Send audio chunk without committing\n   * connection.send({\n   *     audioBase64: base64EncodedAudio,\n   * });\n   *\n   * // Send audio chunk with custom sample rate and previous text\n   * connection.send({\n   *     audioBase64: base64EncodedAudio,\n   *     sampleRate: 16000,\n   *     previousText: \"Previous transcription text\",\n   * });\n   * ```\n   */\n  public send(data: {\n    audioBase64: string;\n    commit?: boolean;\n    sampleRate?: number;\n    previousText?: string;\n  }): void {\n    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n\n    const message: InputAudioChunk = {\n      message_type: \"input_audio_chunk\",\n      audio_base_64: data.audioBase64,\n      commit: data.commit ?? false,\n      sample_rate: data.sampleRate ?? this.currentSampleRate,\n      previous_text: data.previousText,\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  /**\n   * Commits the transcription, signaling that a segment of audio has been sent. This clears the buffer and triggers a COMMITTED_TRANSCRIPT event. Context from previous segments is kept.\n   * Committing a segment triggers a COMMITTED_TRANSCRIPT event.\n   *\n   * @throws {Error} If the WebSocket connection is not open\n   *\n   * @remarks\n   * Only needed when using CommitStrategy.MANUAL.\n   * When using CommitStrategy.VAD, commits are handled automatically by the server.\n   *\n   * @example\n   * ```typescript\n   * // Send all audio chunks\n   * for (const chunk of audioChunks) {\n   *     connection.send({ audioBase64: chunk });\n   * }\n   *\n   * // Finalize the transcription\n   * connection.commit();\n   * ```\n   */\n  public commit(): void {\n    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n\n    const message: InputAudioChunk = {\n      message_type: \"input_audio_chunk\",\n      audio_base_64: \"\",\n      commit: true,\n      sample_rate: this.currentSampleRate,\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  /**\n   * Closes the WebSocket connection and cleans up resources.\n   * This will terminate any ongoing transcription and stop microphone streaming if active.\n   *\n   * @remarks\n   * After calling close(), this connection cannot be reused.\n   * Create a new connection if you need to start transcribing again.\n   *\n   * @example\n   * ```typescript\n   * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n   *     console.log(\"Segment committed:\", data.transcript);\n   *     connection.close();\n   * });\n   * ```\n   */\n  public close(): void {\n    // Cleanup audio resources (microphone stream, audio context)\n    if (this._audioCleanup) {\n      this._audioCleanup();\n    }\n\n    // Close WebSocket connection\n    if (this.websocket) {\n      this.websocket.close(1000, \"User ended session\");\n    }\n  }\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadScribeAudioProcessor = createWorkletModuleLoader(\n  \"scribeAudioProcessor\",\n  // language=JavaScript\n  `/*\n * Scribe Audio Processor for converting microphone audio to PCM16 format\n * Supports resampling for browsers like Firefox that don't support\n * AudioContext sample rate constraints.\n * USED BY @elevenlabs/client\n */\n\nclass ScribeAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffer = [];\n    this.bufferSize = 4096; // Buffer size for optimal chunk transmission\n\n    // Resampling state\n    this.inputSampleRate = null;\n    this.outputSampleRate = null;\n    this.resampleRatio = 1;\n    this.lastSample = 0;\n    this.resampleAccumulator = 0;\n\n    this.port.onmessage = ({ data }) => {\n      if (data.type === \"configure\") {\n        this.inputSampleRate = data.inputSampleRate;\n        this.outputSampleRate = data.outputSampleRate;\n        if (this.inputSampleRate && this.outputSampleRate) {\n          this.resampleRatio = this.inputSampleRate / this.outputSampleRate;\n        }\n      }\n    };\n  }\n\n  // Linear interpolation resampling\n  resample(inputData) {\n    if (this.resampleRatio === 1 || !this.inputSampleRate) {\n      return inputData;\n    }\n\n    const outputSamples = [];\n\n    for (let i = 0; i < inputData.length; i++) {\n      const currentSample = inputData[i];\n\n      // Generate output samples using linear interpolation\n      while (this.resampleAccumulator < 1) {\n        const interpolated =\n          this.lastSample +\n          (currentSample - this.lastSample) * this.resampleAccumulator;\n        outputSamples.push(interpolated);\n        this.resampleAccumulator += this.resampleRatio;\n      }\n\n      this.resampleAccumulator -= 1;\n      this.lastSample = currentSample;\n    }\n\n    return new Float32Array(outputSamples);\n  }\n\n  process(inputs) {\n    const input = inputs[0];\n    if (input.length > 0) {\n      let channelData = input[0]; // Get first channel (mono)\n\n      // Resample if needed (for Firefox and other browsers that don't\n      // support AudioContext sample rate constraints)\n      if (this.resampleRatio !== 1) {\n        channelData = this.resample(channelData);\n      }\n\n      // Add incoming audio to buffer\n      for (let i = 0; i < channelData.length; i++) {\n        this.buffer.push(channelData[i]);\n      }\n\n      // When buffer reaches threshold, convert and send\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = new Float32Array(this.buffer);\n        const int16Array = new Int16Array(float32Array.length);\n\n        // Convert Float32 [-1, 1] to Int16 [-32768, 32767]\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to prevent overflow\n          const sample = Math.max(-1, Math.min(1, float32Array[i]));\n          // Scale to PCM16 range\n          int16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;\n        }\n\n        // Send to main thread as transferable ArrayBuffer\n        this.port.postMessage(\n          {\n            audioData: int16Array.buffer\n          },\n          [int16Array.buffer]\n        );\n\n        // Clear buffer\n        this.buffer = [];\n      }\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"scribeAudioProcessor\", ScribeAudioProcessor);\n\n`\n);\n","import { RealtimeConnection } from \"./connection\";\nimport { loadScribeAudioProcessor } from \"../utils/scribeAudioProcessor.generated\";\n\nexport enum AudioFormat {\n  PCM_8000 = \"pcm_8000\",\n  PCM_16000 = \"pcm_16000\",\n  PCM_22050 = \"pcm_22050\",\n  PCM_24000 = \"pcm_24000\",\n  PCM_44100 = \"pcm_44100\",\n  PCM_48000 = \"pcm_48000\",\n  ULAW_8000 = \"ulaw_8000\",\n}\n\nexport enum CommitStrategy {\n  MANUAL = \"manual\",\n  VAD = \"vad\",\n}\n\ninterface BaseOptions {\n  /**\n   * Token to use for the WebSocket connection. Obtained from the ElevenLabs API.\n   */\n  token: string;\n  /**\n   * Strategy for committing transcriptions.\n   * @default CommitStrategy.MANUAL\n   */\n  commitStrategy?: CommitStrategy;\n  /**\n   * Silence threshold in seconds for VAD (Voice Activity Detection).\n   * Must be a positive number between 0.3 and 3.0\n   */\n  vadSilenceThresholdSecs?: number;\n  /**\n   * Threshold for voice activity detection.\n   * Must be between 0.1 and 0.9.\n   */\n  vadThreshold?: number;\n  /**\n   * Minimum speech duration in milliseconds.\n   * Must be a positive integer between 50 and 2000.\n   */\n  minSpeechDurationMs?: number;\n  /**\n   * Minimum silence duration in milliseconds.\n   * Must be a positive integer between 50 and 2000.\n   */\n  minSilenceDurationMs?: number;\n  /**\n   * Model ID to use for transcription.\n   * Must be a valid model ID.\n   */\n  modelId: string;\n  /**\n   * An ISO-639-1 or ISO-639-3 language_code corresponding to the language of the audio file.\n   * Can sometimes improve transcription performance if known beforehand.\n   */\n  languageCode?: string;\n  /**\n   * Base URI to use for the WebSocket connection.\n   * If not provided, the default URI will be used.\n   */\n  baseUri?: string;\n  /**\n   * Whether to receive a committed_transcript_with_timestamps event which includes word-level timestamps.\n   * @default false\n   */\n  includeTimestamps?: boolean;\n}\n\nexport interface AudioOptions extends BaseOptions {\n  audioFormat: AudioFormat;\n  sampleRate: number;\n  microphone?: never;\n}\n\n/**\n * Options for automatic microphone streaming in the browser.\n */\nexport interface MicrophoneOptions extends BaseOptions {\n  microphone?: {\n    deviceId?: ConstrainDOMString;\n    echoCancellation?: boolean;\n    noiseSuppression?: boolean;\n    autoGainControl?: boolean;\n    channelCount?: number;\n  };\n  audioFormat?: never;\n  sampleRate?: never;\n}\n\n/**\n * Real-time speech-to-text transcription client for browser environments.\n * Supports microphone streaming and manual audio chunk transmission.\n */\n\n// biome-ignore lint/complexity/noStaticOnlyClass: This class is static only because it is a singleton\nexport class ScribeRealtime {\n  private static readonly DEFAULT_BASE_URI = \"wss://api.elevenlabs.io\";\n\n  private static getWebSocketUri(\n    baseUri: string = ScribeRealtime.DEFAULT_BASE_URI\n  ): string {\n    return `${baseUri}/v1/speech-to-text/realtime`;\n  }\n\n  private static buildWebSocketUri(\n    options: AudioOptions | MicrophoneOptions\n  ): string {\n    const baseUri = ScribeRealtime.getWebSocketUri(options.baseUri);\n    const params = new URLSearchParams();\n\n    // Model ID and token are required, so no check required\n    params.append(\"model_id\", options.modelId);\n    params.append(\"token\", options.token);\n\n    // Add optional parameters if provided, with validation\n    if (options.commitStrategy !== undefined) {\n      params.append(\"commit_strategy\", options.commitStrategy);\n    }\n    if (options.audioFormat !== undefined) {\n      params.append(\"audio_format\", options.audioFormat);\n    }\n    if (options.vadSilenceThresholdSecs !== undefined) {\n      if (\n        options.vadSilenceThresholdSecs <= 0.3 ||\n        options.vadSilenceThresholdSecs > 3.0\n      ) {\n        throw new Error(\"vadSilenceThresholdSecs must be between 0.3 and 3.0\");\n      }\n      params.append(\n        \"vad_silence_threshold_secs\",\n        options.vadSilenceThresholdSecs.toString()\n      );\n    }\n    if (options.vadThreshold !== undefined) {\n      if (options.vadThreshold < 0.1 || options.vadThreshold > 0.9) {\n        throw new Error(\"vadThreshold must be between 0.1 and 0.9\");\n      }\n      params.append(\"vad_threshold\", options.vadThreshold.toString());\n    }\n    if (options.minSpeechDurationMs !== undefined) {\n      if (\n        options.minSpeechDurationMs <= 50 ||\n        options.minSpeechDurationMs > 2000\n      ) {\n        throw new Error(\"minSpeechDurationMs must be between 50 and 2000\");\n      }\n      params.append(\n        \"min_speech_duration_ms\",\n        options.minSpeechDurationMs.toString()\n      );\n    }\n    if (options.minSilenceDurationMs !== undefined) {\n      if (\n        options.minSilenceDurationMs <= 50 ||\n        options.minSilenceDurationMs > 2000\n      ) {\n        throw new Error(\"minSilenceDurationMs must be between 50 and 2000\");\n      }\n      params.append(\n        \"min_silence_duration_ms\",\n        options.minSilenceDurationMs.toString()\n      );\n    }\n    if (options.languageCode !== undefined) {\n      params.append(\"language_code\", options.languageCode);\n    }\n    if (options.includeTimestamps !== undefined) {\n      params.append(\n        \"include_timestamps\",\n        options.includeTimestamps ? \"true\" : \"false\"\n      );\n    }\n\n    const queryString = params.toString();\n    return queryString ? `${baseUri}?${queryString}` : baseUri;\n  }\n\n  /**\n   * Establishes a WebSocket connection for real-time speech-to-text transcription.\n   *\n   * @param options - Configuration options for the connection\n   * @returns A RealtimeConnection instance\n   *\n   * @example\n   * ```typescript\n   * // Manual audio streaming\n   * const connection = Scribe.connect({\n   *     token: \"...\",\n   *     modelId: \"scribe_v2_realtime\",\n   *     audioFormat: AudioFormat.PCM_16000,\n   *     sampleRate: 16000,\n   * });\n   *\n   * // Automatic microphone streaming\n   * const connection = Scribe.connect({\n   *     token: \"...\",\n   *     modelId: \"scribe_v2_realtime\",\n   *     microphone: {\n   *         echoCancellation: true,\n   *         noiseSuppression: true\n   *     }\n   * });\n   * ```\n   */\n  public static connect(\n    options: AudioOptions | MicrophoneOptions\n  ): RealtimeConnection {\n    if (!options.modelId) {\n      throw new Error(\"modelId is required\");\n    }\n\n    // Create connection object first so users can attach event listeners before messages arrive\n    const sampleRate =\n      \"microphone\" in options && options.microphone\n        ? 16000\n        : (options as AudioOptions).sampleRate;\n    const connection = new RealtimeConnection(sampleRate);\n\n    // Build WebSocket URI with query parameters\n    const uri = ScribeRealtime.buildWebSocketUri(options);\n\n    const websocket = new WebSocket(uri);\n\n    // If microphone mode, set up streaming handler\n    if (\"microphone\" in options && options.microphone) {\n      websocket.addEventListener(\"open\", () => {\n        ScribeRealtime.streamFromMicrophone(\n          options as MicrophoneOptions,\n          connection\n        );\n      });\n    }\n\n    connection.setWebSocket(websocket);\n\n    return connection;\n  }\n\n  private static async streamFromMicrophone(\n    options: MicrophoneOptions,\n    connection: RealtimeConnection\n  ): Promise<void> {\n    const TARGET_SAMPLE_RATE = 16000;\n\n    try {\n      // Get microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          deviceId: options.microphone?.deviceId,\n          echoCancellation: options.microphone?.echoCancellation ?? true,\n          noiseSuppression: options.microphone?.noiseSuppression ?? true,\n          autoGainControl: options.microphone?.autoGainControl ?? true,\n          channelCount: options.microphone?.channelCount ?? 1,\n          sampleRate: { ideal: TARGET_SAMPLE_RATE },\n        },\n      });\n\n      // Get the actual sample rate from the stream - the ideal may not have been honored\n      const trackSettings = stream.getAudioTracks()[0]?.getSettings();\n      const streamSampleRate = trackSettings?.sampleRate;\n\n      // Create audio context matching the stream's sample rate to avoid Firefox errors\n      // Firefox requires the AudioContext to match the microphone's native sample rate\n      const audioContext = new AudioContext(\n        streamSampleRate ? { sampleRate: streamSampleRate } : {}\n      );\n\n      // Load scribe worklet\n      await loadScribeAudioProcessor(audioContext.audioWorklet);\n\n      // Set up audio pipeline\n      const source = audioContext.createMediaStreamSource(stream);\n      const scribeNode = new AudioWorkletNode(\n        audioContext,\n        \"scribeAudioProcessor\"\n      );\n\n      // Configure the worklet with sample rate info for resampling\n      // (only needed when AudioContext sample rate differs from target)\n      if (audioContext.sampleRate !== TARGET_SAMPLE_RATE) {\n        scribeNode.port.postMessage({\n          type: \"configure\",\n          inputSampleRate: audioContext.sampleRate,\n          outputSampleRate: TARGET_SAMPLE_RATE,\n        });\n      }\n\n      // Handle audio data from worklet\n      scribeNode.port.onmessage = event => {\n        const { audioData } = event.data;\n        // Convert ArrayBuffer to base64\n        const bytes = new Uint8Array(audioData);\n        let binary = \"\";\n        for (let i = 0; i < bytes.length; i++) {\n          binary += String.fromCharCode(bytes[i]);\n        }\n        const base64Audio = btoa(binary);\n\n        connection.send({ audioBase64: base64Audio });\n      };\n\n      // Connect audio pipeline\n      source.connect(scribeNode);\n\n      // Resume audio context if needed\n      if (audioContext.state === \"suspended\") {\n        await audioContext.resume();\n      }\n\n      // Store cleanup function\n      connection._audioCleanup = () => {\n        stream.getTracks().forEach(track => {\n          track.stop();\n        });\n        source.disconnect();\n        scribeNode.disconnect();\n        audioContext.close();\n      };\n    } catch (error) {\n      console.error(\"Failed to start microphone streaming:\", error);\n      throw error;\n    }\n  }\n}\n","import { BaseConversation, type PartialOptions } from \"./BaseConversation\";\nimport { TextConversation } from \"./TextConversation\";\nimport { VoiceConversation } from \"./VoiceConversation\";\n\nexport type {\n  Mode,\n  Role,\n  Options,\n  PartialOptions,\n  ClientToolsConfig,\n  Callbacks,\n  Status,\n  AudioWorkletConfig,\n} from \"./BaseConversation\";\nexport type { InputConfig } from \"./utils/input\";\nexport type { OutputConfig } from \"./utils/output\";\nexport { Input } from \"./utils/input\";\nexport { Output } from \"./utils/output\";\nexport type {\n  IncomingSocketEvent,\n  VadScoreEvent,\n  AudioAlignmentEvent,\n} from \"./utils/events\";\nexport type {\n  SessionConfig,\n  BaseSessionConfig,\n  DisconnectionDetails,\n  Language,\n  ConnectionType,\n  FormatConfig,\n} from \"./utils/BaseConnection\";\nexport { createConnection } from \"./utils/ConnectionFactory\";\nexport { WebSocketConnection } from \"./utils/WebSocketConnection\";\nexport { WebRTCConnection } from \"./utils/WebRTCConnection\";\nexport { postOverallFeedback } from \"./utils/postOverallFeedback\";\nexport { SessionConnectionError } from \"./utils/errors\";\nexport { VoiceConversation } from \"./VoiceConversation\";\nexport { TextConversation } from \"./TextConversation\";\n\n// Scribe exports\nexport {\n  Scribe,\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n  RealtimeConnection,\n} from \"./scribe\";\nexport type {\n  AudioOptions,\n  MicrophoneOptions,\n  WebSocketMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"./scribe\";\n\nexport class Conversation extends BaseConversation {\n  public static startSession(options: PartialOptions): Promise<Conversation> {\n    const fullOptions = Conversation.getFullOptions(options);\n    return fullOptions.textOnly\n      ? TextConversation.startSession(fullOptions)\n      : VoiceConversation.startSession(fullOptions);\n  }\n}\n"],"names":["EMPTY_FREQUENCY_DATA","Uint8Array","BaseConversation","getFullOptions","partialOptions","_partialOptions$overr","textOnly","options","_options$overrides$co","_options$overrides","textOnlyOverride","overrides","conversation","console","warn","isTextOnly","_extends","clientTools","onConnect","onDebug","onDisconnect","onError","onMessage","onAudio","onModeChange","onStatusChange","onCanSendFeedbackChange","onInterruption","constructor","connection","_this","lastInterruptTimestamp","this","mode","status","volume","currentEventId","lastFeedbackEventId","canSendFeedback","endSessionWithDetails","async","details","updateStatus","handleEndSession","parsedEvent","type","handleInterruption","handleAgentResponse","handleUserTranscript","handleTentativeAgentResponse","handleClientToolCall","error","Error","message","String","clientToolName","client_tool_call","tool_name","toolCallId","tool_call_id","handleAudio","handleVadScore","sendMessage","event_id","ping_event","handleMCPToolCall","handleMCPConnectionStatus","handleAgentToolRequest","handleAgentToolResponse","handleConversationMetadata","handleAsrInitiationMetadata","handleAgentChatResponsePart","handleErrorEvent","setVolume","conversationId","updateMode","endSession","reason","close","updateCanSendFeedback","event","interruption_event","source","role","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","onVadScore","vadScore","vad_score_event","vad_score","Object","prototype","hasOwnProperty","call","_await$this$options$c","result","parameters","formattedResult","JSON","stringify","is_error","e","onUnhandledClientToolCall","onMCPToolCall","mcp_tool_call","onMCPConnectionStatus","mcp_connection_status","onAgentToolRequest","agent_tool_request","agent_tool_response","context","CloseEvent","onAgentToolResponse","onConversationMetadata","conversation_initiation_metadata_event","onAsrInitiationMetadata","asr_initiation_metadata_event","onAgentChatResponsePart","text_response_part","errorType","error_event","error_type","code","debugMessage","debug_message","Event","getId","isOpen","setMicMuted","isMuted","getInputByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","sendFeedback","like","score","sendContextualUpdate","text","sendUserMessage","sendUserActivity","sendMCPToolApprovalResult","isApproved","is_approved","BaseConnection","config","queue","disconnectionDetails","onDisconnectCallback","onMessageCallback","onModeChangeCallback","debug","info","callback","length","queueMicrotask","forEach","_this$onModeChangeCal","disconnect","_this$onDisconnectCal","handleMessage","push","parseFormat","format","formatPart","sampleRatePart","split","includes","sampleRate","Number","parseInt","isNaN","PACKAGE_VERSION","isValidSocketEvent","CONVERSATION_INITIATION_CLIENT_DATA_TYPE","constructOverrides","_config$overrides","overridesEvent","_config$overrides$age","_config$overrides$age2","_config$overrides$age3","_config$overrides$tts","_config$overrides$tts2","_config$overrides$tts3","_config$overrides$tts4","_config$overrides$con","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","speed","stability","similarity_boost","similarityBoost","text_only","customLlmExtraBody","custom_llm_extra_body","dynamicVariables","dynamic_variables","userId","user_id","client","source_info","version","SessionConnectionError","super","closeCode","closeReason","name","WebSocketConnection","socket","inputFormat","outputFormat","addEventListener","setTimeout","undefined","parse","data","create","_config$origin","_config$overrides2","origin","url","signedUrl","separator","agentId","protocols","authorization","WebSocket","conversationConfig","Promise","resolve","reject","_socket","send","once","conversation_id","agent_output_audio_format","user_input_audio_format","_socket2","arrayBufferToBase64","b","buffer","window","btoa","fromCharCode","base64ToArrayBuffer","base64","binaryString","atob","len","bytes","i","charCodeAt","URLCache","Map","createWorkletModuleLoader","sourceCode","worklet","path","cachedUrl","get","addModule","set","blob","Blob","blobURL","URL","createObjectURL","_unused","revokeObjectURL","moduleURL","loadRawAudioProcessor","WebRTCConnection","room","isConnected","audioEventId","audioCaptureContext","audioElements","outputDeviceId","outputAnalyser","outputFrequencyData","setupRoomEventListeners","conversationToken","replace","fetch","ok","statusText","json","token","msg","Room","Date","now","livekitUrl","_room$name$match","connect","onConnected","off","RoomEvent","Connected","on","match","localParticipant","setMicrophoneEnabled","Disconnected","toString","ConnectionStateChanged","state","ConnectionState","DataReceived","payload","_participant","TextDecoder","decode","TrackSubscribed","track","_publication","participant","kind","Track","Kind","Audio","identity","remoteAudioTrack","audioElement","attach","autoplay","controls","setSinkId","style","display","document","body","appendChild","setupAudioCapture","ActiveSpeakersChanged","speakers","startsWith","ParticipantDisconnected","_participant$identity","audioTrackPublications","publication","stop","catch","element","parentNode","removeChild","TextEncoder","encode","publishData","reliable","getRoom","micTrackPublication","getTrackPublication","Source","Microphone","mute","unmute","_error","audioContext","AudioContext","createAnalyser","fftSize","smoothingTimeConstant","mediaStream","MediaStream","mediaStreamTrack","createMediaStreamSource","audioWorklet","AudioWorkletNode","port","postMessage","onmessage","audioData","maxVolume","base64Audio","eventId","audio_event","audio_base_64","setAudioVolume","setAudioOutputDevice","deviceId","HTMLAudioElement","promises","map","all","setAudioInputDevice","currentMicTrackPublication","unpublishTrack","audioConstraints","exact","echoCancellation","noiseSuppression","autoGainControl","channelCount","ideal","audioTrack","createLocalAudioTrack","publishTrack","recoveryError","_this$outputFrequency","frequencyBinCount","getByteFrequencyData","createConnection","connectionType","determineConnectionType","isIosDevice","navigator","platform","userAgent","applyDelay","delayConfig","default","android","delay","_delayConfig$android","test","_delayConfig$ios","ios","TextConversation","startSession","fullOptions","connectionDelay","_connection","defaultConstraints","Input","preferHeadphonesForIosDevices","inputDeviceId","workletPaths","libsampleratePath","inputStream","idealDevice","mediaDevices","enumerateDevices","find","d","keyword","label","toLowerCase","getDeviceIdConstraint","supportsSampleRateConstraint","getSupportedConstraints","analyser","libsamplerateUrl","constraints","voiceIsolation","getUserMedia","audio","resume","permissions","query","_inputStream","_context","getTracks","mediaStreamSource","settingInput","handlePermissionsChange","_track$getSettings","getAudioTracks","getSettings","setInputDevice","forgetInputStreamAndSource","removeEventListener","setMuted","newInputStream","loadAudioConcatProcessor","Output","gain","createGain","src","load","destination","createMediaStreamDestination","srcObject","stream","_audioElement","_audioElement2","pause","setOutputDevice","VoiceConversation","requestWakeLock","wakeLock","request","_e","_options$useWakeLock","input","output","preliminaryInputStream","useWakeLock","_preliminaryInputStre","_preliminaryInputStre2","_input","_output","_wakeLock","release","inputFrequencyData","visibilityChangeHandler","onInputWorkletMessage","user_audio_chunk","onOutputWorkletMessage","finished","addAudioBase64Chunk","chunk","cancelScheduledValues","currentTime","value","fadeOutAudio","exponentialRampToValueAtTime","calculateVolume","frequencyData","clampedVolume","isFinite","Math","min","max","_this$wakeLock","visibilityState","released","then","lock","_this$wakeLock2","_this$options$onAudio","_this$options","alignment","onAudioAlignment","_this$inputFrequencyD","changeInputDevice","newInput","changeOutputDevice","newOutput","postOverallFeedback","likeOrFeedback","feedback","rating","comment","method","headers","EventEmitter","listeners","listener","has","Set","eventListeners","add","delete","emit","args","RealtimeEvents","RealtimeConnection","websocket","eventEmitter","currentSampleRate","_audioCleanup","setWebSocket","readyState","OPEN","message_type","SESSION_STARTED","PARTIAL_TRANSCRIPT","COMMITTED_TRANSCRIPT","COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS","AUTH_ERROR","ERROR","QUOTA_EXCEEDED","COMMIT_THROTTLED","TRANSCRIBER_ERROR","UNACCEPTED_TERMS","RATE_LIMITED","INPUT_ERROR","QUEUE_OVERFLOW","RESOURCE_EXHAUSTED","SESSION_TIME_LIMIT_EXCEEDED","CHUNK_SIZE_EXCEEDED","INSUFFICIENT_AUDIO_ACTIVITY","log","wasClean","errorMessage","CLOSE","_data$commit","_data$sampleRate","audioBase64","commit","sample_rate","previous_text","previousText","loadScribeAudioProcessor","AudioFormat","CommitStrategy","ScribeRealtime","getWebSocketUri","baseUri","DEFAULT_BASE_URI","buildWebSocketUri","params","URLSearchParams","append","modelId","commitStrategy","audioFormat","vadSilenceThresholdSecs","vadThreshold","minSpeechDurationMs","minSilenceDurationMs","languageCode","includeTimestamps","queryString","microphone","uri","streamFromMicrophone","TARGET_SAMPLE_RATE","_options$microphone","_options$microphone$e","_options$microphone2","_options$microphone$n","_options$microphone3","_options$microphone$a","_options$microphone4","_options$microphone$c","_options$microphone5","_stream$getAudioTrack","trackSettings","streamSampleRate","scribeNode","inputSampleRate","outputSampleRate","binary","Conversation"],"mappings":"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"}},
    {"offset": {"line": 1571, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@elevenlabs/react/dist/lib.modern.js","sources":["file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/react/src/scribe.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/react/src/index.ts","file:///C:/Users/cindy/MyToxicPetCat/node_modules/%40elevenlabs/react/src/version.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from \"react\";\nimport { Scribe, RealtimeEvents } from \"@elevenlabs/client\";\nimport type {\n  RealtimeConnection,\n  AudioOptions,\n  MicrophoneOptions,\n  AudioFormat,\n  CommitStrategy,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"@elevenlabs/client\";\n\n// ============= Types =============\n\nexport type ScribeStatus =\n  | \"disconnected\"\n  | \"connecting\"\n  | \"connected\"\n  | \"transcribing\"\n  | \"error\";\n\nexport interface WordTimestamp {\n  text?: string;\n  /** Start time in seconds */\n  start?: number;\n  /** End time in seconds */\n  end?: number;\n  type?: \"word\" | \"spacing\";\n  speaker_id?: string;\n  logprob?: number;\n  characters?: string[];\n}\n\nexport interface TranscriptSegment {\n  id: string;\n  text: string;\n  timestamp: number;\n  isFinal: boolean;\n  /** Word-level timestamps (only present when includeTimestamps is enabled) */\n  words?: WordTimestamp[];\n}\n\nexport interface ScribeCallbacks {\n  onSessionStarted?: () => void;\n  onPartialTranscript?: (data: { text: string }) => void;\n  onCommittedTranscript?: (data: { text: string }) => void;\n  onCommittedTranscriptWithTimestamps?: (data: {\n    text: string;\n    words?: WordTimestamp[];\n  }) => void;\n  /** Called for any error (also called when specific error callbacks fire) */\n  onError?: (error: Error | Event) => void;\n  onAuthError?: (data: { error: string }) => void;\n  onQuotaExceededError?: (data: { error: string }) => void;\n  onCommitThrottledError?: (data: { error: string }) => void;\n  onTranscriberError?: (data: { error: string }) => void;\n  onUnacceptedTermsError?: (data: { error: string }) => void;\n  onRateLimitedError?: (data: { error: string }) => void;\n  onInputError?: (data: { error: string }) => void;\n  onQueueOverflowError?: (data: { error: string }) => void;\n  onResourceExhaustedError?: (data: { error: string }) => void;\n  onSessionTimeLimitExceededError?: (data: { error: string }) => void;\n  onChunkSizeExceededError?: (data: { error: string }) => void;\n  onInsufficientAudioActivityError?: (data: { error: string }) => void;\n\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n}\n\nexport interface ScribeHookOptions extends ScribeCallbacks {\n  // Connection options\n  token?: string;\n  modelId?: string;\n  baseUri?: string;\n\n  // VAD options\n  commitStrategy?: CommitStrategy;\n  vadSilenceThresholdSecs?: number;\n  vadThreshold?: number;\n  minSpeechDurationMs?: number;\n  minSilenceDurationMs?: number;\n  languageCode?: string;\n\n  // Microphone options (for automatic microphone mode)\n  microphone?: {\n    deviceId?: string;\n    echoCancellation?: boolean;\n    noiseSuppression?: boolean;\n    autoGainControl?: boolean;\n    channelCount?: number;\n  };\n\n  // Manual audio options\n  audioFormat?: AudioFormat;\n  sampleRate?: number;\n\n  // Auto-connect on mount\n  autoConnect?: boolean;\n\n  // Include timestamps\n  includeTimestamps?: boolean;\n}\n\nexport interface UseScribeReturn {\n  // State\n  status: ScribeStatus;\n  isConnected: boolean;\n  isTranscribing: boolean;\n  partialTranscript: string;\n  committedTranscripts: TranscriptSegment[];\n  error: string | null;\n\n  // Connection methods\n  connect: (options?: Partial<ScribeHookOptions>) => Promise<void>;\n  disconnect: () => void;\n\n  // Audio methods (for manual mode)\n  sendAudio: (\n    audioBase64: string,\n    options?: { commit?: boolean; sampleRate?: number; previousText?: string }\n  ) => void;\n  commit: () => void;\n\n  // Utility methods\n  clearTranscripts: () => void;\n  getConnection: () => RealtimeConnection | null;\n}\n\n// ============= Hook Implementation =============\n\nexport function useScribe(options: ScribeHookOptions = {}): UseScribeReturn {\n  const {\n    // Callbacks\n    onSessionStarted,\n    onPartialTranscript,\n    onCommittedTranscript,\n    onCommittedTranscriptWithTimestamps,\n    onError,\n    onAuthError,\n    onQuotaExceededError,\n    onCommitThrottledError,\n    onTranscriberError,\n    onUnacceptedTermsError,\n    onRateLimitedError,\n    onInputError,\n    onQueueOverflowError,\n    onResourceExhaustedError,\n    onSessionTimeLimitExceededError,\n    onChunkSizeExceededError,\n    onInsufficientAudioActivityError,\n    onConnect,\n    onDisconnect,\n\n    // Connection options\n    token: defaultToken,\n    modelId: defaultModelId,\n    baseUri: defaultBaseUri,\n    commitStrategy: defaultCommitStrategy,\n    vadSilenceThresholdSecs: defaultVadSilenceThresholdSecs,\n    vadThreshold: defaultVadThreshold,\n    minSpeechDurationMs: defaultMinSpeechDurationMs,\n    minSilenceDurationMs: defaultMinSilenceDurationMs,\n    languageCode: defaultLanguageCode,\n\n    // Mode options\n    microphone: defaultMicrophone,\n    audioFormat: defaultAudioFormat,\n    sampleRate: defaultSampleRate,\n\n    // Auto-connect\n    autoConnect = false,\n\n    // Timestamps\n    includeTimestamps: defaultIncludeTimestamps,\n  } = options;\n\n  const connectionRef = useRef<RealtimeConnection | null>(null);\n\n  const [status, setStatus] = useState<ScribeStatus>(\"disconnected\");\n  const [partialTranscript, setPartialTranscript] = useState<string>(\"\");\n  const [committedTranscripts, setCommittedTranscripts] = useState<\n    TranscriptSegment[]\n  >([]);\n  const [error, setError] = useState<string | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      connectionRef.current?.close();\n    };\n  }, []);\n\n  const connect = useCallback(\n    async (runtimeOptions: Partial<ScribeHookOptions> = {}) => {\n      if (connectionRef.current) {\n        console.warn(\"Already connected\");\n        return;\n      }\n\n      try {\n        setStatus(\"connecting\");\n        setError(null);\n\n        // Merge default options with runtime options\n        const token = runtimeOptions.token || defaultToken;\n        const modelId = runtimeOptions.modelId || defaultModelId;\n\n        if (!token) {\n          throw new Error(\"Token is required\");\n        }\n        if (!modelId) {\n          throw new Error(\"Model ID is required\");\n        }\n\n        // Determine mode: microphone or manual\n        const microphone = runtimeOptions.microphone || defaultMicrophone;\n        const audioFormat = runtimeOptions.audioFormat || defaultAudioFormat;\n        const sampleRate = runtimeOptions.sampleRate || defaultSampleRate;\n\n        let connection: RealtimeConnection;\n\n        // Include timestamps if explicitly requested OR if the callback is provided\n        const includeTimestamps =\n          runtimeOptions.includeTimestamps ??\n          defaultIncludeTimestamps ??\n          !!(\n            runtimeOptions.onCommittedTranscriptWithTimestamps ||\n            onCommittedTranscriptWithTimestamps\n          );\n\n        if (microphone) {\n          // Microphone mode\n          connection = Scribe.connect({\n            token,\n            modelId,\n            baseUri: runtimeOptions.baseUri || defaultBaseUri,\n            commitStrategy:\n              runtimeOptions.commitStrategy || defaultCommitStrategy,\n            vadSilenceThresholdSecs:\n              runtimeOptions.vadSilenceThresholdSecs ||\n              defaultVadSilenceThresholdSecs,\n            vadThreshold: runtimeOptions.vadThreshold || defaultVadThreshold,\n            minSpeechDurationMs:\n              runtimeOptions.minSpeechDurationMs || defaultMinSpeechDurationMs,\n            minSilenceDurationMs:\n              runtimeOptions.minSilenceDurationMs ||\n              defaultMinSilenceDurationMs,\n            languageCode: runtimeOptions.languageCode || defaultLanguageCode,\n            microphone,\n            includeTimestamps,\n          } as MicrophoneOptions);\n        } else if (audioFormat && sampleRate) {\n          // Manual audio mode\n          connection = Scribe.connect({\n            token,\n            modelId,\n            baseUri: runtimeOptions.baseUri || defaultBaseUri,\n            commitStrategy:\n              runtimeOptions.commitStrategy || defaultCommitStrategy,\n            vadSilenceThresholdSecs:\n              runtimeOptions.vadSilenceThresholdSecs ||\n              defaultVadSilenceThresholdSecs,\n            vadThreshold: runtimeOptions.vadThreshold || defaultVadThreshold,\n            minSpeechDurationMs:\n              runtimeOptions.minSpeechDurationMs || defaultMinSpeechDurationMs,\n            minSilenceDurationMs:\n              runtimeOptions.minSilenceDurationMs ||\n              defaultMinSilenceDurationMs,\n            languageCode: runtimeOptions.languageCode || defaultLanguageCode,\n            includeTimestamps,\n            audioFormat,\n            sampleRate,\n          } as AudioOptions);\n        } else {\n          throw new Error(\n            \"Either microphone options or (audioFormat + sampleRate) must be provided\"\n          );\n        }\n\n        connectionRef.current = connection;\n\n        // Set up event listeners\n        connection.on(RealtimeEvents.SESSION_STARTED, () => {\n          setStatus(\"connected\");\n          onSessionStarted?.();\n        });\n\n        connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data: unknown) => {\n          const message = data as PartialTranscriptMessage;\n          setPartialTranscript(message.text);\n          setStatus(\"transcribing\");\n          onPartialTranscript?.(message);\n        });\n\n        connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data: unknown) => {\n          const message = data as CommittedTranscriptMessage;\n          const segment: TranscriptSegment = {\n            id: `${Date.now()}-${Math.random()}`,\n            text: message.text,\n            timestamp: Date.now(),\n            isFinal: true,\n          };\n          setCommittedTranscripts(prev => [...prev, segment]);\n          setPartialTranscript(\"\");\n          onCommittedTranscript?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS,\n          (data: unknown) => {\n            const message = data as CommittedTranscriptWithTimestampsMessage;\n            const segment: TranscriptSegment = {\n              id: `${Date.now()}-${Math.random()}`,\n              text: message.text,\n              timestamp: Date.now(),\n              isFinal: true,\n              words: message.words,\n            };\n            setCommittedTranscripts(prev => [...prev, segment]);\n            setPartialTranscript(\"\");\n            onCommittedTranscriptWithTimestamps?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.ERROR, (err: unknown) => {\n          const message = err as ScribeErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onError?.(new Error(message.error));\n        });\n\n        connection.on(RealtimeEvents.AUTH_ERROR, (data: unknown) => {\n          const message = data as ScribeAuthErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onAuthError?.(message);\n        });\n\n        connection.on(RealtimeEvents.QUOTA_EXCEEDED, (data: unknown) => {\n          const message = data as ScribeQuotaExceededErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onQuotaExceededError?.(message);\n        });\n\n        connection.on(RealtimeEvents.COMMIT_THROTTLED, (data: unknown) => {\n          const message = data as ScribeCommitThrottledErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onCommitThrottledError?.(message);\n        });\n\n        connection.on(RealtimeEvents.TRANSCRIBER_ERROR, (data: unknown) => {\n          const message = data as ScribeTranscriberErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onTranscriberError?.(message);\n        });\n\n        connection.on(RealtimeEvents.UNACCEPTED_TERMS, (data: unknown) => {\n          const message = data as ScribeUnacceptedTermsErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onUnacceptedTermsError?.(message);\n        });\n\n        connection.on(RealtimeEvents.RATE_LIMITED, (data: unknown) => {\n          const message = data as ScribeRateLimitedErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onRateLimitedError?.(message);\n        });\n\n        connection.on(RealtimeEvents.INPUT_ERROR, (data: unknown) => {\n          const message = data as ScribeInputErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onInputError?.(message);\n        });\n\n        connection.on(RealtimeEvents.QUEUE_OVERFLOW, (data: unknown) => {\n          const message = data as ScribeQueueOverflowErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onQueueOverflowError?.(message);\n        });\n\n        connection.on(RealtimeEvents.RESOURCE_EXHAUSTED, (data: unknown) => {\n          const message = data as ScribeResourceExhaustedErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onResourceExhaustedError?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED,\n          (data: unknown) => {\n            const message = data as ScribeSessionTimeLimitExceededErrorMessage;\n            setError(message.error);\n            setStatus(\"error\");\n            onSessionTimeLimitExceededError?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.CHUNK_SIZE_EXCEEDED, (data: unknown) => {\n          const message = data as ScribeChunkSizeExceededErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onChunkSizeExceededError?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY,\n          (data: unknown) => {\n            const message = data as ScribeInsufficientAudioActivityErrorMessage;\n            setError(message.error);\n            setStatus(\"error\");\n            onInsufficientAudioActivityError?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.OPEN, () => {\n          onConnect?.();\n        });\n\n        connection.on(RealtimeEvents.CLOSE, () => {\n          setStatus(\"disconnected\");\n          connectionRef.current = null;\n          onDisconnect?.();\n        });\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to connect\";\n        setError(errorMessage);\n        setStatus(\"error\");\n        throw err;\n      }\n    },\n    [\n      defaultToken,\n      defaultModelId,\n      defaultBaseUri,\n      defaultCommitStrategy,\n      defaultVadSilenceThresholdSecs,\n      defaultVadThreshold,\n      defaultMinSpeechDurationMs,\n      defaultMinSilenceDurationMs,\n      defaultLanguageCode,\n      defaultMicrophone,\n      defaultAudioFormat,\n      defaultSampleRate,\n      defaultIncludeTimestamps,\n      onSessionStarted,\n      onPartialTranscript,\n      onCommittedTranscript,\n      onCommittedTranscriptWithTimestamps,\n      onError,\n      onAuthError,\n      onQuotaExceededError,\n      onCommitThrottledError,\n      onTranscriberError,\n      onUnacceptedTermsError,\n      onRateLimitedError,\n      onInputError,\n      onQueueOverflowError,\n      onResourceExhaustedError,\n      onSessionTimeLimitExceededError,\n      onChunkSizeExceededError,\n      onInsufficientAudioActivityError,\n      onConnect,\n      onDisconnect,\n    ]\n  );\n\n  const disconnect = useCallback(() => {\n    connectionRef.current?.close();\n    connectionRef.current = null;\n    setStatus(\"disconnected\");\n  }, []);\n\n  const sendAudio = useCallback(\n    (\n      audioBase64: string,\n      options?: { commit?: boolean; sampleRate?: number; previousText?: string }\n    ) => {\n      if (!connectionRef.current) {\n        throw new Error(\"Not connected to Scribe\");\n      }\n      connectionRef.current.send({ audioBase64, ...options });\n    },\n    []\n  );\n\n  const commit = useCallback(() => {\n    if (!connectionRef.current) {\n      throw new Error(\"Not connected to Scribe\");\n    }\n    connectionRef.current.commit();\n  }, []);\n\n  const clearTranscripts = useCallback(() => {\n    setCommittedTranscripts([]);\n    setPartialTranscript(\"\");\n  }, []);\n\n  const getConnection = useCallback(() => {\n    return connectionRef.current;\n  }, []);\n\n  // Auto-connect if enabled\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n  }, [autoConnect, connect]);\n\n  return {\n    // State\n    status,\n    isConnected: status === \"connected\" || status === \"transcribing\",\n    isTranscribing: status === \"transcribing\",\n    partialTranscript,\n    committedTranscripts,\n    error,\n\n    // Methods\n    connect,\n    disconnect,\n    sendAudio,\n    commit,\n    clearTranscripts,\n    getConnection,\n  };\n}\n\n// Export types and enums from client for convenience\nexport {\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n} from \"@elevenlabs/client\";\nexport type { RealtimeConnection } from \"@elevenlabs/client\";\n","import { useEffect, useRef, useState } from \"react\";\nimport {\n  Conversation,\n  type SessionConfig,\n  type Options,\n  type ClientToolsConfig,\n  type InputConfig,\n  type AudioWorkletConfig,\n  type OutputConfig,\n  type FormatConfig,\n  type Mode,\n  type Status,\n  type Callbacks,\n} from \"@elevenlabs/client\";\n\n// Device configuration types for audio device switching\nexport type DeviceFormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n  outputDeviceId?: string;\n};\n\nexport type DeviceInputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n  inputDeviceId?: string;\n};\n\nimport { PACKAGE_VERSION } from \"./version\";\n\nexport type Location = \"us\" | \"global\" | \"eu-residency\" | \"in-residency\";\n\nexport function parseLocation(location: string = \"us\"): Location {\n  switch (location) {\n    case \"eu-residency\":\n    case \"in-residency\":\n    case \"us\":\n    case \"global\":\n      return location;\n    default:\n      console.warn(\n        `[ConversationalAI] Invalid server-location: ${location}. Defaulting to \"us\"`\n      );\n      return \"us\";\n  }\n}\n\nexport function getOriginForLocation(location: Location): string {\n  const originMap: Record<Location, string> = {\n    us: \"wss://api.elevenlabs.io\",\n    \"eu-residency\": \"wss://api.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://api.in.residency.elevenlabs.io\",\n    global: \"wss://api.elevenlabs.io\",\n  };\n\n  return originMap[location];\n}\n\nexport function getLivekitUrlForLocation(location: Location): string {\n  const livekitUrlMap: Record<Location, string> = {\n    us: \"wss://livekit.rtc.elevenlabs.io\",\n    \"eu-residency\": \"wss://livekit.rtc.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://livekit.rtc.in.residency.elevenlabs.io\",\n    global: \"wss://livekit.rtc.elevenlabs.io\",\n  };\n\n  return livekitUrlMap[location];\n}\n\nexport type {\n  Role,\n  Mode,\n  Status,\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n  VadScoreEvent,\n  AudioAlignmentEvent,\n  InputConfig,\n  FormatConfig,\n  VoiceConversation,\n  TextConversation,\n  Callbacks,\n} from \"@elevenlabs/client\";\nexport { postOverallFeedback } from \"@elevenlabs/client\";\n\n// Scribe exports\nexport {\n  useScribe,\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n} from \"./scribe\";\nexport type {\n  ScribeStatus,\n  TranscriptSegment,\n  WordTimestamp,\n  ScribeCallbacks,\n  ScribeHookOptions,\n  UseScribeReturn,\n  RealtimeConnection,\n} from \"./scribe\";\n\nexport type HookOptions = Partial<\n  SessionConfig &\n    HookCallbacks &\n    ClientToolsConfig &\n    InputConfig &\n    OutputConfig &\n    AudioWorkletConfig &\n    FormatConfig & {\n      serverLocation?: Location | string;\n    }\n>;\nexport type ControlledState = {\n  micMuted?: boolean;\n  volume?: number;\n};\nexport type HookCallbacks = Pick<\n  Callbacks,\n  | \"onConnect\"\n  | \"onDisconnect\"\n  | \"onError\"\n  | \"onMessage\"\n  | \"onAudio\"\n  | \"onModeChange\"\n  | \"onStatusChange\"\n  | \"onCanSendFeedbackChange\"\n  | \"onDebug\"\n  | \"onUnhandledClientToolCall\"\n  | \"onVadScore\"\n  | \"onInterruption\"\n  | \"onAgentToolResponse\"\n  | \"onAgentToolRequest\"\n  | \"onConversationMetadata\"\n  | \"onMCPToolCall\"\n  | \"onMCPConnectionStatus\"\n  | \"onAsrInitiationMetadata\"\n  | \"onAgentChatResponsePart\"\n  | \"onAudioAlignment\"\n>;\n\nexport function useConversation<T extends HookOptions & ControlledState>(\n  props: T = {} as T\n) {\n  const { micMuted, volume, serverLocation, ...defaultOptions } = props;\n  const conversationRef = useRef<Conversation | null>(null);\n  const lockRef = useRef<Promise<Conversation> | null>(null);\n  const shouldEndRef = useRef(false);\n  const [status, setStatus] = useState<Status>(\"disconnected\");\n  const [canSendFeedback, setCanSendFeedback] = useState(false);\n  const [mode, setMode] = useState<Mode>(\"listening\");\n\n  const micMutedRef = useRef<boolean | undefined>(micMuted);\n  const volumeRef = useRef<number | undefined>(volume);\n\n  micMutedRef.current = micMuted;\n  volumeRef.current = volume;\n\n  useEffect(() => {\n    if (micMuted !== undefined) {\n      conversationRef?.current?.setMicMuted(micMuted);\n    }\n  }, [micMuted]);\n\n  useEffect(() => {\n    if (volume !== undefined) {\n      conversationRef?.current?.setVolume({ volume });\n    }\n  }, [volume]);\n\n  useEffect(() => {\n    return () => {\n      shouldEndRef.current = true;\n      if (lockRef.current) {\n        lockRef.current.then(conv => conv.endSession());\n      } else {\n        conversationRef.current?.endSession();\n      }\n    };\n  }, []);\n\n  return {\n    startSession: (async (options?: HookOptions) => {\n      if (conversationRef.current?.isOpen()) {\n        return conversationRef.current.getId();\n      }\n\n      if (lockRef.current) {\n        const conversation = await lockRef.current;\n        return conversation.getId();\n      }\n\n      shouldEndRef.current = false;\n\n      try {\n        const resolvedServerLocation = parseLocation(\n          options?.serverLocation || serverLocation\n        );\n        const origin = getOriginForLocation(resolvedServerLocation);\n        const calculatedLivekitUrl = getLivekitUrlForLocation(\n          resolvedServerLocation\n        );\n\n        lockRef.current = Conversation.startSession({\n          ...(defaultOptions ?? {}),\n          ...(options ?? {}),\n          origin,\n\n          livekitUrl:\n            options?.livekitUrl ||\n            defaultOptions?.livekitUrl ||\n            calculatedLivekitUrl,\n          overrides: {\n            ...(defaultOptions?.overrides ?? {}),\n            ...(options?.overrides ?? {}),\n            client: {\n              ...(defaultOptions?.overrides?.client ?? {}),\n              ...(options?.overrides?.client ?? {}),\n              source:\n                options?.overrides?.client?.source ||\n                defaultOptions?.overrides?.client?.source ||\n                \"react_sdk\",\n              version:\n                options?.overrides?.client?.version ||\n                defaultOptions?.overrides?.client?.version ||\n                PACKAGE_VERSION,\n            },\n          },\n          // Pass through user-provided callbacks\n          onConnect: options?.onConnect || defaultOptions?.onConnect,\n          onDisconnect: options?.onDisconnect || defaultOptions?.onDisconnect,\n          onError: options?.onError || defaultOptions?.onError,\n          onMessage: options?.onMessage || defaultOptions?.onMessage,\n          onAudio: options?.onAudio || defaultOptions?.onAudio,\n          onDebug: options?.onDebug || defaultOptions?.onDebug,\n          onUnhandledClientToolCall:\n            options?.onUnhandledClientToolCall ||\n            defaultOptions?.onUnhandledClientToolCall,\n          onVadScore: options?.onVadScore || defaultOptions?.onVadScore,\n          onInterruption:\n            options?.onInterruption || defaultOptions?.onInterruption,\n          onAgentToolRequest:\n            options?.onAgentToolRequest || defaultOptions?.onAgentToolRequest,\n          onAgentToolResponse:\n            options?.onAgentToolResponse || defaultOptions?.onAgentToolResponse,\n          onConversationMetadata:\n            options?.onConversationMetadata ||\n            defaultOptions?.onConversationMetadata,\n          onMCPToolCall:\n            options?.onMCPToolCall || defaultOptions?.onMCPToolCall,\n          onMCPConnectionStatus:\n            options?.onMCPConnectionStatus ||\n            defaultOptions?.onMCPConnectionStatus,\n          onAsrInitiationMetadata:\n            options?.onAsrInitiationMetadata ||\n            defaultOptions?.onAsrInitiationMetadata,\n          onAgentChatResponsePart:\n            options?.onAgentChatResponsePart ||\n            defaultOptions?.onAgentChatResponsePart,\n          onAudioAlignment:\n            options?.onAudioAlignment || defaultOptions?.onAudioAlignment,\n          onModeChange: ({ mode }) => {\n            setMode(mode);\n            (options?.onModeChange || defaultOptions?.onModeChange)?.({ mode });\n          },\n          onStatusChange: ({ status }) => {\n            setStatus(status);\n            (options?.onStatusChange || defaultOptions?.onStatusChange)?.({\n              status,\n            });\n          },\n          onCanSendFeedbackChange: ({ canSendFeedback }) => {\n            setCanSendFeedback(canSendFeedback);\n            (\n              options?.onCanSendFeedbackChange ||\n              defaultOptions?.onCanSendFeedbackChange\n            )?.({ canSendFeedback });\n          },\n        } as Options);\n\n        conversationRef.current = await lockRef.current;\n\n        // Check if session was cancelled while connecting\n        if (shouldEndRef.current) {\n          await conversationRef.current.endSession();\n          conversationRef.current = null;\n          lockRef.current = null;\n          throw new Error(\"Session cancelled during connection\");\n        }\n\n        // Persist controlled state between sessions using refs to get current values\n        if (micMutedRef.current !== undefined) {\n          conversationRef.current.setMicMuted(micMutedRef.current);\n        }\n        if (volumeRef.current !== undefined) {\n          conversationRef.current.setVolume({ volume: volumeRef.current });\n        }\n\n        return conversationRef.current.getId();\n      } finally {\n        lockRef.current = null;\n      }\n    }) as T extends SessionConfig\n      ? (options?: HookOptions) => Promise<string>\n      : (options: SessionConfig & HookOptions) => Promise<string>,\n    endSession: async () => {\n      shouldEndRef.current = true;\n      const pendingConnection = lockRef.current;\n      const conversation = conversationRef.current;\n      conversationRef.current = null;\n\n      if (pendingConnection) {\n        const conv = await pendingConnection;\n        await conv.endSession();\n      } else {\n        await conversation?.endSession();\n      }\n    },\n    setVolume: ({ volume }: { volume: number }) => {\n      conversationRef.current?.setVolume({ volume });\n    },\n    getInputByteFrequencyData: () => {\n      return conversationRef.current?.getInputByteFrequencyData();\n    },\n    getOutputByteFrequencyData: () => {\n      return conversationRef.current?.getOutputByteFrequencyData();\n    },\n    getInputVolume: () => {\n      return conversationRef.current?.getInputVolume() ?? 0;\n    },\n    getOutputVolume: () => {\n      return conversationRef.current?.getOutputVolume() ?? 0;\n    },\n    sendFeedback: (like: boolean) => {\n      conversationRef.current?.sendFeedback(like);\n    },\n    getId: () => {\n      return conversationRef.current?.getId();\n    },\n    sendContextualUpdate: (text: string) => {\n      conversationRef.current?.sendContextualUpdate(text);\n    },\n    sendUserMessage: (text: string) => {\n      conversationRef.current?.sendUserMessage(text);\n    },\n    sendUserActivity: () => {\n      conversationRef.current?.sendUserActivity();\n    },\n    sendMCPToolApprovalResult: (toolCallId: string, isApproved: boolean) => {\n      conversationRef.current?.sendMCPToolApprovalResult(\n        toolCallId,\n        isApproved\n      );\n    },\n    changeInputDevice: async (\n      config: DeviceFormatConfig & DeviceInputConfig\n    ) => {\n      if (\n        conversationRef.current &&\n        \"changeInputDevice\" in conversationRef.current\n      ) {\n        return await (\n          conversationRef.current as unknown as {\n            changeInputDevice: (config: any) => Promise<any>;\n          }\n        ).changeInputDevice(config);\n      }\n      throw new Error(\n        \"Device switching is only available for voice conversations\"\n      );\n    },\n    changeOutputDevice: async (config: DeviceFormatConfig) => {\n      if (\n        conversationRef.current &&\n        \"changeOutputDevice\" in conversationRef.current\n      ) {\n        return await (\n          conversationRef.current as unknown as {\n            changeOutputDevice: (config: any) => Promise<any>;\n          }\n        ).changeOutputDevice(config);\n      }\n      throw new Error(\n        \"Device switching is only available for voice conversations\"\n      );\n    },\n    status,\n    canSendFeedback,\n    micMuted,\n    isSpeaking: mode === \"speaking\",\n  };\n}\n\n// const con = useConversation({agentId: \"\"})\n","// This file is auto-generated during build\nexport const PACKAGE_VERSION = \"0.14.0\";\n"],"names":["useScribe","options","onSessionStarted","onPartialTranscript","onCommittedTranscript","onCommittedTranscriptWithTimestamps","onError","onAuthError","onQuotaExceededError","onCommitThrottledError","onTranscriberError","onUnacceptedTermsError","onRateLimitedError","onInputError","onQueueOverflowError","onResourceExhaustedError","onSessionTimeLimitExceededError","onChunkSizeExceededError","onInsufficientAudioActivityError","onConnect","onDisconnect","token","defaultToken","modelId","defaultModelId","baseUri","defaultBaseUri","commitStrategy","defaultCommitStrategy","vadSilenceThresholdSecs","defaultVadSilenceThresholdSecs","vadThreshold","defaultVadThreshold","minSpeechDurationMs","defaultMinSpeechDurationMs","minSilenceDurationMs","defaultMinSilenceDurationMs","languageCode","defaultLanguageCode","microphone","defaultMicrophone","audioFormat","defaultAudioFormat","sampleRate","defaultSampleRate","autoConnect","includeTimestamps","defaultIncludeTimestamps","connectionRef","useRef","status","setStatus","useState","partialTranscript","setPartialTranscript","committedTranscripts","setCommittedTranscripts","error","setError","useEffect","_connectionRef$curren","current","close","connect","useCallback","async","runtimeOptions","console","warn","_ref","_runtimeOptions$inclu","Error","connection","Scribe","on","RealtimeEvents","SESSION_STARTED","PARTIAL_TRANSCRIPT","data","message","text","COMMITTED_TRANSCRIPT","segment","id","Date","now","Math","random","timestamp","isFinal","prev","COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS","words","ERROR","err","AUTH_ERROR","QUOTA_EXCEEDED","COMMIT_THROTTLED","TRANSCRIBER_ERROR","UNACCEPTED_TERMS","RATE_LIMITED","INPUT_ERROR","QUEUE_OVERFLOW","RESOURCE_EXHAUSTED","SESSION_TIME_LIMIT_EXCEEDED","CHUNK_SIZE_EXCEEDED","INSUFFICIENT_AUDIO_ACTIVITY","OPEN","CLOSE","errorMessage","disconnect","_connectionRef$curren2","sendAudio","audioBase64","send","_extends","commit","clearTranscripts","getConnection","isConnected","isTranscribing","parseLocation","location","getOriginForLocation","us","global","getLivekitUrlForLocation","useConversation","props","micMuted","volume","serverLocation","defaultOptions","_objectWithoutPropertiesLoose","_excluded","conversationRef","lockRef","shouldEndRef","canSendFeedback","setCanSendFeedback","mode","setMode","micMutedRef","volumeRef","_conversationRef$curr","undefined","setMicMuted","_conversationRef$curr2","setVolume","_conversationRef$curr3","then","conv","endSession","startSession","_conversationRef$curr4","isOpen","getId","_defaultOptions$overr","_options$overrides","_defaultOptions$overr2","_defaultOptions$overr3","_options$overrides$cl","_options$overrides2","_options$overrides3","_defaultOptions$overr4","_options$overrides4","_defaultOptions$overr5","resolvedServerLocation","origin","calculatedLivekitUrl","Conversation","livekitUrl","overrides","client","source","version","onMessage","onAudio","onDebug","onUnhandledClientToolCall","onVadScore","onInterruption","onAgentToolRequest","onAgentToolResponse","onConversationMetadata","onMCPToolCall","onMCPConnectionStatus","onAsrInitiationMetadata","onAgentChatResponsePart","onAudioAlignment","onModeChange","onStatusChange","_ref2","onCanSendFeedbackChange","_ref3","pendingConnection","conversation","_conversationRef$curr5","getInputByteFrequencyData","_conversationRef$curr6","getOutputByteFrequencyData","_conversationRef$curr7","getInputVolume","_conversationRef$curr8","_conversationRef$curr9","getOutputVolume","_conversationRef$curr0","_conversationRef$curr1","sendFeedback","like","_conversationRef$curr10","_conversationRef$curr11","sendContextualUpdate","_conversationRef$curr12","sendUserMessage","_conversationRef$curr13","sendUserActivity","_conversationRef$curr14","sendMCPToolApprovalResult","toolCallId","isApproved","_conversationRef$curr15","changeInputDevice","config","changeOutputDevice","isSpeaking"],"mappings":"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"}}]
}